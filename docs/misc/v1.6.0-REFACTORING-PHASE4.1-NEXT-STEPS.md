# v1.6.0 Refactoring Phase 4.1 - Content Script Refactoring Next Steps

**Date Created:** 2025-11-19  
**Current Status:** Phase 2.10 Complete (68% overall progress), Phase 4 Ready to
Start  
**Previous Work:** Phase 2.10 complete - All panel components extracted, facade
pattern implemented  
**Repository:** copy-URL-on-hover_ChunkyEdition  
**Branch:** copilot/continue-refactoring-project-phase2

---

## Executive Summary

Phase 2.10 (Manager Panel Refactor) is **COMPLETE**. All 5 panel components
extracted with 141 comprehensive tests, panel.js reduced from 1497 to 408 lines
(-73%), zero ESLint errors in all panel components. **Phase 4 (Content Script
Refactor) is next priority** - modularize content.js by extracting URL
detection, UI rendering, and event handling into separate components.

**Current State:**

- ✅ Phase 0-1: Infrastructure & Domain/Storage (100%)
- ✅ Phase 2.1-2.10: QuickTabsManager & Panel Refactor (100%)
- ✅ Phase 3.1-3.2: Background Script Refactor (100%)
- ⏳ Phase 4: Content Script Refactor (0% - NEXT PRIORITY)
- ⏳ Phase 5-7: Remaining phases (0%)

**Test Status:**

- **724/726 tests passing** (722 + 2 skipped)
- **+141 tests added in Phase 2.10**
- **0 regressions**

**ESLint Status:**

- **60 errors, 25 warnings** (all panel components: 0 errors, 0 warnings)
- **Panel.js:** 0 errors ✅

**Key Files:**

- `content.js` (~2500 lines - TO REFACTOR)
- `src/content/site-handlers/*.js` (100+ site-specific handlers)
- `src/content/social-media.js` (social media handlers)

---

## Phase 4: Content Script Refactor - Overview

**Goal:** Transform monolithic content.js into modular architecture with
separate components for URL detection, UI rendering, and event handling.

**Current State:**

- content.js: ~2500 lines, complex, tightly coupled
- 100+ site-specific handlers mixed with generic logic
- UI rendering, event handling, and URL detection intertwined

**Target Architecture:**

```
src/content/
├── url-detection/
│   ├── SiteHandlerRegistry.js      (handler registration & management)
│   ├── HoverDetectionPipeline.js   (mouseover → handler → URL flow)
│   └── handlers/
│       ├── GenericHandler.js       (fallback for sites without specific handler)
│       ├── TwitterHandler.js       (Twitter-specific URL extraction)
│       ├── RedditHandler.js        (Reddit-specific URL extraction)
│       └── ... (100+ site handlers)
├── ui/
│   ├── NotificationRenderer.js     (tooltip/notification display)
│   ├── NotificationStyler.js       (user-configured styles)
│   ├── AnimationController.js      (slide/pop/fade animations)
│   └── UIManager.js                (facade for all UI operations)
└── events/
    ├── KeyboardEventHandler.js     (copy/text/open-tab shortcuts)
    ├── MouseEventHandler.js        (mouseover/mouseout with debouncing)
    └── EventCoordinator.js         (manage all event listeners)
```

---

## Phase 4.1: URL Detection System (CURRENT PRIORITY)

### Component 1: SiteHandlerRegistry

**Goal:** Extract site handler registration and management into dedicated
registry

**Estimated Effort:** ~4-6 hours

**Expected Output:**

- `src/content/url-detection/SiteHandlerRegistry.js` (~200-250 lines)
- `tests/unit/content/SiteHandlerRegistry.test.js` (~25-30 tests)
- 0 ESLint errors, 0 ESLint warnings

**Current Implementation:** Site handlers registered in content.js as giant
if-else chain

**Target Implementation:**

```javascript
/**
 * SiteHandlerRegistry
 * Manages registration and lookup of site-specific URL handlers
 */
export class SiteHandlerRegistry {
  constructor() {
    this.handlers = new Map(); // domain → handler
    this.cache = new Map(); // element → { url, timestamp }
  }

  /**
   * Register a site-specific handler
   * @param {string} domain - Domain pattern (e.g., 'twitter.com')
   * @param {Function} handler - Handler function (element → url)
   * @param {number} priority - Handler priority (higher = checked first)
   */
  register(domain, handler, priority = 0) {
    this.handlers.set(domain, { handler, priority, domain });
  }

  /**
   * Get handler for hostname
   * @param {string} hostname - Site hostname
   * @returns {Function|null} Handler function or null
   */
  getHandler(hostname) {
    // Try exact match first
    if (this.handlers.has(hostname)) {
      return this.handlers.get(hostname).handler;
    }

    // Try partial match (e.g., 'twitter.com' matches 'mobile.twitter.com')
    for (const [domain, { handler }] of this.handlers) {
      if (hostname.includes(domain)) {
        return handler;
      }
    }

    return null;
  }

  /**
   * Extract URL from element using appropriate handler
   * @param {HTMLElement} element - Element to extract URL from
   * @returns {string|null} Extracted URL or null
   */
  extractUrl(element) {
    // Check cache first (memoization)
    const cached = this.cache.get(element);
    if (cached && Date.now() - cached.timestamp < 1000) {
      return cached.url;
    }

    const hostname = window.location.hostname;
    const handler = this.getHandler(hostname);

    let url = null;
    if (handler) {
      try {
        url = handler(element);
      } catch (err) {
        console.error(`Handler for ${hostname} failed:`, err);
      }
    }

    // Cache result
    this.cache.set(element, { url, timestamp: Date.now() });

    return url;
  }

  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
  }
}
```

**Key Features:**

- Registry pattern for handler management
- Priority-based handler lookup
- Exact and partial domain matching
- URL extraction caching for performance
- Error handling for handler failures
- Fallback to null if no handler found

**Test Coverage (~25-30 tests):**

- ✅ Register handlers with domains
- ✅ Exact domain matching
- ✅ Partial domain matching (e.g., mobile.twitter.com → twitter.com handler)
- ✅ Priority-based handler selection
- ✅ URL extraction with caching
- ✅ Cache expiration (1 second TTL)
- ✅ Handler error handling
- ✅ Fallback when no handler found
- ✅ clearCache() functionality

**Integration:**

- Used by HoverDetectionPipeline
- Replaces giant if-else chain in content.js
- All existing site handlers migrate to registry pattern

---

### Component 2: HoverDetectionPipeline

**Goal:** Extract hover detection and URL extraction orchestration

**Estimated Effort:** ~3-4 hours

**Expected Output:**

- `src/content/url-detection/HoverDetectionPipeline.js` (~150-200 lines)
- `tests/unit/content/HoverDetectionPipeline.test.js` (~20-25 tests)
- 0 ESLint errors, 0 ESLint warnings

**Target Implementation:**

```javascript
/**
 * HoverDetectionPipeline
 * Coordinates mouseover events → handler selection → URL extraction flow
 */
export class HoverDetectionPipeline {
  constructor(registry, options = {}) {
    this.registry = registry; // SiteHandlerRegistry instance
    this.debounceMs = options.debounceMs || 100;
    this.lastHoverTime = 0;
    this.callbacks = {
      onUrlDetected: options.onUrlDetected || (() => {}),
      onUrlCleared: options.onUrlCleared || (() => {})
    };
  }

  /**
   * Handle mouseover event
   * @param {MouseEvent} event - Mouseover event
   */
  handleMouseOver(event) {
    const now = Date.now();
    if (now - this.lastHoverTime < this.debounceMs) {
      return; // Debounce rapid hovers
    }
    this.lastHoverTime = now;

    const element = event.target;
    const url = this.registry.extractUrl(element);

    if (url) {
      this.callbacks.onUrlDetected(url, element);
    } else {
      this.callbacks.onUrlCleared();
    }
  }

  /**
   * Handle mouseout event
   * @param {MouseEvent} event - Mouseout event
   */
  handleMouseOut(_event) {
    this.callbacks.onUrlCleared();
  }

  /**
   * Set callbacks
   * @param {Object} callbacks - Callbacks object
   */
  setCallbacks(callbacks) {
    this.callbacks = { ...this.callbacks, ...callbacks };
  }
}
```

**Key Features:**

- Mouseover/mouseout event handling
- Debouncing for rapid hovers (100ms default)
- URL extraction via registry
- Callbacks for detected/cleared URLs
- Clean separation of concerns

**Test Coverage (~20-25 tests):**

- ✅ Mouseover triggers URL extraction
- ✅ Debouncing prevents rapid processing
- ✅ Callbacks invoked on URL detection
- ✅ Callbacks invoked on URL clear
- ✅ Mouseout clears URL
- ✅ Integration with SiteHandlerRegistry

---

### Component 3: GenericHandler (Fallback)

**Goal:** Extract generic URL detection as fallback handler

**Estimated Effort:** ~2-3 hours

**Expected Output:**

- `src/content/url-detection/handlers/GenericHandler.js` (~100-150 lines)
- `tests/unit/content/handlers/GenericHandler.test.js` (~15-20 tests)
- 0 ESLint errors, 0 ESLint warnings

**Target Implementation:**

```javascript
/**
 * GenericHandler
 * Fallback URL extraction for sites without specific handlers
 */
export class GenericHandler {
  /**
   * Extract URL from element using generic strategies
   * @param {HTMLElement} element - Element to extract URL from
   * @returns {string|null} Extracted URL or null
   */
  static extract(element) {
    // Strategy 1: Check if element is an <a> tag
    const link = element.closest('a');
    if (link?.href) {
      return GenericHandler._validateUrl(link.href);
    }

    // Strategy 2: Check data attributes (data-url, data-href, etc.)
    const dataUrl = GenericHandler._extractDataUrl(element);
    if (dataUrl) {
      return dataUrl;
    }

    // Strategy 3: Check for onclick handlers with URLs
    const onclickUrl = GenericHandler._extractOnclickUrl(element);
    if (onclickUrl) {
      return onclickUrl;
    }

    return null;
  }

  /**
   * Validate URL format
   * @param {string} url - URL to validate
   * @returns {string|null} Valid URL or null
   * @private
   */
  static _validateUrl(url) {
    try {
      const parsed = new URL(url, window.location.href);
      // Only return http/https URLs
      return ['http:', 'https:'].includes(parsed.protocol) ? parsed.href : null;
    } catch {
      return null;
    }
  }

  /**
   * Extract URL from data attributes
   * @param {HTMLElement} element - Element to check
   * @returns {string|null} Extracted URL or null
   * @private
   */
  static _extractDataUrl(element) {
    const dataAttrs = ['data-url', 'data-href', 'data-link', 'data-src'];
    for (const attr of dataAttrs) {
      const value = element.getAttribute(attr);
      if (value) {
        const validated = GenericHandler._validateUrl(value);
        if (validated) return validated;
      }
    }
    return null;
  }

  /**
   * Extract URL from onclick handlers
   * @param {HTMLElement} element - Element to check
   * @returns {string|null} Extracted URL or null
   * @private
   */
  static _extractOnclickUrl(element) {
    const onclick = element.getAttribute('onclick');
    if (!onclick) return null;

    // Match common patterns like window.open('url') or location.href='url'
    const patterns = [
      /window\.open\(['"]([^'"]+)['"]\)/,
      /location\.href\s*=\s*['"]([^'"]+)['"]/,
      /href\s*=\s*['"]([^'"]+)['"]/
    ];

    for (const pattern of patterns) {
      const match = onclick.match(pattern);
      if (match?.[1]) {
        const validated = GenericHandler._validateUrl(match[1]);
        if (validated) return validated;
      }
    }

    return null;
  }
}
```

**Key Features:**

- Multi-strategy URL extraction
- <a> tag href detection
- Data attribute checking
- Onclick handler parsing
- URL validation

**Test Coverage (~15-20 tests):**

- ✅ Extract from <a> tags
- ✅ Extract from data-url attributes
- ✅ Extract from onclick handlers
- ✅ URL validation (http/https only)
- ✅ Fallback when no URL found
- ✅ Relative URL resolution

---

## Phase 4.1 Implementation Strategy

### Step 1: Create SiteHandlerRegistry (~4-6 hours)

1. **Create component file**
   - Path: `src/content/url-detection/SiteHandlerRegistry.js`
   - Implement registry, registration, lookup, caching

2. **Create comprehensive tests**
   - Path: `tests/unit/content/SiteHandlerRegistry.test.js`
   - 25-30 tests covering all functionality

3. **Verify quality**
   - Run tests: `npm test`
   - Lint: `npm run lint`
   - Ensure 0 errors, 0 warnings

### Step 2: Create HoverDetectionPipeline (~3-4 hours)

1. **Create component file**
   - Path: `src/content/url-detection/HoverDetectionPipeline.js`
   - Implement mouseover/mouseout handling, debouncing

2. **Create comprehensive tests**
   - Path: `tests/unit/content/HoverDetectionPipeline.test.js`
   - 20-25 tests covering event handling, callbacks

3. **Verify quality**
   - Run tests: `npm test`
   - Lint: `npm run lint`
   - Integration with SiteHandlerRegistry

### Step 3: Create GenericHandler (~2-3 hours)

1. **Create component file**
   - Path: `src/content/url-detection/handlers/GenericHandler.js`
   - Implement multi-strategy extraction

2. **Create comprehensive tests**
   - Path: `tests/unit/content/handlers/GenericHandler.test.js`
   - 15-20 tests covering all strategies

3. **Verify quality**
   - Run tests: `npm test`
   - Lint: `npm run lint`

### Step 4: Integrate Components into content.js (~2-3 hours)

1. **Update content.js imports**

   ```javascript
   import { SiteHandlerRegistry } from './content/url-detection/SiteHandlerRegistry.js';
   import { HoverDetectionPipeline } from './content/url-detection/HoverDetectionPipeline.js';
   import { GenericHandler } from './content/url-detection/handlers/GenericHandler.js';
   ```

2. **Initialize components**

   ```javascript
   const registry = new SiteHandlerRegistry();

   // Register generic handler as fallback
   registry.register('*', GenericHandler.extract, 0);

   // Register site-specific handlers (migrate existing)
   registry.register('twitter.com', extractTwitterUrl, 10);
   registry.register('reddit.com', extractRedditUrl, 10);
   // ... more handlers

   const pipeline = new HoverDetectionPipeline(registry, {
     onUrlDetected: (url, element) => {
       // Show notification
       // Prepare Quick Tab creation
     },
     onUrlCleared: () => {
       // Hide notification
     }
   });
   ```

3. **Replace existing hover logic**
   - Remove old mouseover/mouseout handlers
   - Use pipeline.handleMouseOver / handleMouseOut

4. **Test integration**
   - Verify all tests still pass
   - Test on multiple sites
   - Verify no regressions

### Step 5: Update Master Checklist

1. **Read** `docs/misc/v1.6.0-REFACTORING-MASTER-CHECKLIST.md`
2. **Update** Phase 4.1 progress:
   - Mark SiteHandlerRegistry as complete [x]
   - Mark HoverDetectionPipeline as complete [x]
   - Mark GenericHandler as complete [x]
   - Update "Last Updated" date
   - Update "Overall Progress" percentage
   - Update "Progress Summary" table

---

## Success Criteria for Phase 4.1 Completion

Phase 4.1 is **COMPLETE** when:

1. ✅ SiteHandlerRegistry implemented with 25-30 tests passing
2. ✅ HoverDetectionPipeline implemented with 20-25 tests passing
3. ✅ GenericHandler implemented with 15-20 tests passing
4. ✅ All 60-75 new tests passing (no regressions in existing 724 tests)
5. ✅ 0 ESLint errors in all new components
6. ✅ Integration with content.js verified
7. ✅ All existing URL detection working (Twitter, Reddit, etc.)
8. ✅ Master checklist updated

---

## Expected Metrics After Phase 4.1

**Tests:**

- Before: 724 passing
- After: ~784-799 passing (+60-75 tests)

**ESLint:**

- New components: 0 errors, 0 warnings
- Overall: Should remain at 60 errors or improve

**Code Structure:**

- content.js: Reduced by ~300-400 lines
- New structure: Better separation of concerns
- Maintainability: Improved (testable components)

---

## Next Phases After 4.1

**Phase 4.2:** UI Rendering System

- Extract NotificationRenderer
- Extract NotificationStyler
- Extract AnimationController
- Create UIManager facade

**Phase 4.3:** Event Handling System

- Extract KeyboardEventHandler
- Extract MouseEventHandler
- Create EventCoordinator

---

## Reference Documentation

- **Master Checklist:** `docs/misc/v1.6.0-REFACTORING-MASTER-CHECKLIST.md`
- **Refactoring Plan:**
  `docs/manual/1.5.9 docs/copy-url-on-hover-refactoring-plan-v2-evidence-based.md`
- **Infrastructure Plan:**
  `docs/manual/1.5.9 docs/infrastructure-testing-changes-refactoring.md`

---

**END OF NEXT STEPS DOCUMENT**
