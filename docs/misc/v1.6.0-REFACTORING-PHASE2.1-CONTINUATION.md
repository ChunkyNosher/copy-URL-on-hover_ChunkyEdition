# v1.6.0 Refactoring - Phase 2.1 Continuation Handoff

**Date:** 2025-11-18  
**Agent:** refactor-specialist  
**Status:** Phase 2.1 In Progress - 5 of 10 Components Complete (50%)  
**Next Agent:** Continue handler/coordinator extraction and facade integration

---

## üéØ Executive Summary

**Phase 2.1 Goal:** Decompose QuickTabsManager god object (1453 lines ‚Üí ~400
lines facade)

**Current Progress:**

- ‚úÖ **5 managers/handlers extracted** (StorageManager, BroadcastManager,
  StateManager, EventManager, CreateHandler)
- ‚úÖ **1020 lines extracted** (70% of target reduction)
- ‚úÖ **116 new tests added** (all passing, 100% coverage for extracted code)
- ‚è≥ **5 components remaining** (3 Handlers + 2 Coordinators)
- ‚è≥ **Facade integration** (refactor index.js to use all components)

---

## ‚úÖ Completed Work This Session

### CreateHandler ‚úÖ (170 lines, 13 tests) - **NEW**

**File:** `src/features/quick-tabs/handlers/CreateHandler.js`  
**Tests:** `tests/unit/handlers/CreateHandler.test.js`

**Responsibilities:**

- Generate ID if not provided
- Auto-assign container if not provided
- Handle existing tabs (render if not rendered)
- Create QuickTabWindow instance
- Store in tabs Map
- Broadcast CREATE message
- Emit QUICK_TAB_CREATED event

**Key Methods:**

- `create(options)` - Main public method (cc=3)
- `_handleExistingTab(id)` - Render existing tab logic
- `_createNewTab(id, cookieStoreId, options)` - New tab creation logic
- `_getDefaults()` - Default option values
- `_getTabOptions(...)` - Tab options builder
- `_broadcastCreation(...)` - Broadcast CREATE message
- `_emitCreationEvent(id, url)` - Emit creation event

**Extracted From:** QuickTabsManager lines 903-992  
**Complexity Reduction:** cc=25 ‚Üí cc=3 (88% reduction)

**Quality Metrics:**

- ‚úÖ ESLint: 0 errors
- ‚úÖ Test Coverage: 100% (13 tests)
- ‚úÖ Cyclomatic Complexity: <3 (target: <9)
- ‚úÖ Max Lines Per Function: <70

---

## üìã Remaining Work for Phase 2.1

### Step 1: Extract Remaining Handlers (3 files, ~400 lines total, ~50 tests)

#### 1.1 UpdateHandler - **NEXT TO DO**

**Extract from QuickTabsManager:**

- `handlePositionChange(id, left, top)` - Lines 1209-1219
- `handlePositionChangeEnd(id, left, top)` - Lines 1221-1265
- `handleSizeChange(id, width, height)` - Lines 1267-1278
- `handleSizeChangeEnd(id, width, height)` - Lines 1280-1320

**Responsibilities:**

- Handle position updates (drag) - update immediately, no save/broadcast
- Handle size updates (resize) - update immediately, no save/broadcast
- Handle position change end - update, save, broadcast
- Handle size change end - update, save, broadcast
- Debounced broadcasting for smooth updates

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/UpdateHandler.js
export class UpdateHandler {
  constructor(quickTabsMap, broadcastManager, storageManager, eventBus) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;
    this.eventBus = eventBus;
  }

  handlePositionChange(id, left, top) {
    // Update tab position immediately (no save/broadcast)
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Direct style update for smooth dragging
    tab.container.style.left = `${left}px`;
    tab.container.style.top = `${top}px`;
  }

  handlePositionChangeEnd(id, left, top) {
    // Update, save, broadcast
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Update internal state
    tab.position = { left, top };

    // Save to storage
    this.storageManager.save(Array.from(this.quickTabsMap.values()));

    // Broadcast to other tabs
    this.broadcastManager.notifyPositionUpdate(id, left, top);

    // Emit event
    this.eventBus?.emit('tab:position-updated', { id, left, top });
  }

  handleSizeChange(id, width, height) {
    // Update tab size immediately (no save/broadcast)
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Direct style update for smooth resizing
    tab.container.style.width = `${width}px`;
    tab.container.style.height = `${height}px`;
  }

  handleSizeChangeEnd(id, width, height) {
    // Update, save, broadcast
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Update internal state
    tab.size = { width, height };

    // Save to storage
    this.storageManager.save(Array.from(this.quickTabsMap.values()));

    // Broadcast to other tabs
    this.broadcastManager.notifySizeUpdate(id, width, height);

    // Emit event
    this.eventBus?.emit('tab:size-updated', { id, width, height });
  }
}
```

**Tests to Write:**

- Position change (no broadcast/save)
- Position change end (broadcast + save)
- Size change (no broadcast/save)
- Size change end (broadcast + save)
- Handle non-existent tab ID gracefully
- Verify broadcast messages sent
- Verify storage saved
- Verify events emitted

**Estimated Lines:** ~120 lines  
**Estimated Tests:** ~15 tests  
**Target Complexity:** cc <3

---

#### 1.2 VisibilityHandler

**Extract from QuickTabsManager:**

- `handleSoloToggle(quickTabId, newSoloedTabs)` - Lines 1322-1371
- `handleMuteToggle(quickTabId, newMutedTabs)` - Lines 1373-1420
- `handleMinimize(id)` - Lines 1044-1087
- `handleFocus(id)` - Lines 1089-1105

**Responsibilities:**

- Solo/mute toggle logic - update arrays, save, broadcast
- Minimize/restore logic - update state, manage minimized panel
- Focus management - bring to front, update z-index

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/VisibilityHandler.js
export class VisibilityHandler {
  constructor(
    quickTabsMap,
    broadcastManager,
    storageManager,
    stateManager,
    minimizedManager,
    eventBus
  ) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;
    this.stateManager = stateManager;
    this.minimizedManager = minimizedManager;
    this.eventBus = eventBus;
  }

  handleSoloToggle(quickTabId, newSoloedTabs) {
    const tab = this.quickTabsMap.get(quickTabId);
    if (!tab) return;

    // Update solo state
    tab.soloedOnTabs = newSoloedTabs;

    // If solo is set, clear mute
    if (newSoloedTabs.length > 0) {
      tab.mutedOnTabs = [];
    }

    // Save to storage
    this.storageManager.save(Array.from(this.quickTabsMap.values()));

    // Broadcast to other tabs
    this.broadcastManager.notifySolo(quickTabId, newSoloedTabs);

    // Emit event
    this.eventBus?.emit('tab:solo-toggled', {
      id: quickTabId,
      soloedOnTabs: newSoloedTabs
    });
  }

  handleMuteToggle(quickTabId, newMutedTabs) {
    const tab = this.quickTabsMap.get(quickTabId);
    if (!tab) return;

    // Update mute state
    tab.mutedOnTabs = newMutedTabs;

    // If mute is set, clear solo
    if (newMutedTabs.length > 0) {
      tab.soloedOnTabs = [];
    }

    // Save to storage
    this.storageManager.save(Array.from(this.quickTabsMap.values()));

    // Broadcast to other tabs
    this.broadcastManager.notifyMute(quickTabId, newMutedTabs);

    // Emit event
    this.eventBus?.emit('tab:mute-toggled', {
      id: quickTabId,
      mutedOnTabs: newMutedTabs
    });
  }

  handleMinimize(id) {
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Update minimized state
    tab.minimized = true;

    // Add to minimized manager
    this.minimizedManager.add(tab);

    // Save to storage
    this.storageManager.save(Array.from(this.quickTabsMap.values()));

    // Broadcast to other tabs
    this.broadcastManager.notifyMinimize(id);

    // Emit event
    this.eventBus?.emit('tab:minimized', { id });
  }

  handleFocus(id) {
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Bring to front
    const newZIndex = this.stateManager.bringToFront(id);
    tab.updateZIndex(newZIndex);

    // Emit event
    this.eventBus?.emit('tab:focused', { id, zIndex: newZIndex });
  }
}
```

**Tests to Write:**

- Solo toggle adds/removes tabs
- Solo toggle clears mute
- Mute toggle adds/removes tabs
- Mute toggle clears solo
- Minimize updates state and minimized manager
- Focus brings to front and updates z-index
- Broadcast messages sent
- Storage saved
- Events emitted

**Estimated Lines:** ~180 lines  
**Estimated Tests:** ~20 tests  
**Target Complexity:** cc <3

---

#### 1.3 DestroyHandler

**Extract from QuickTabsManager:**

- `handleDestroy(id)` - Lines 994-1042
- `closeById(id)` - Lines 1163-1171
- `closeAll()` - Lines 1194-1207

**Responsibilities:**

- Close single Quick Tab - remove from map, minimized manager, broadcast, notify
  background
- Close all Quick Tabs - iterate and close each
- Cleanup DOM elements
- Emit destruction events

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/DestroyHandler.js
export class DestroyHandler {
  constructor(
    quickTabsMap,
    broadcastManager,
    storageManager,
    minimizedManager,
    eventBus,
    Events
  ) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;
    this.minimizedManager = minimizedManager;
    this.eventBus = eventBus;
    this.Events = Events;
  }

  handleDestroy(id) {
    const tab = this.quickTabsMap.get(id);
    if (!tab) {
      console.warn('[DestroyHandler] Tab not found:', id);
      return;
    }

    // Remove from minimized manager
    this.minimizedManager.remove(id);

    // Remove from tabs map
    this.quickTabsMap.delete(id);

    // Broadcast close to other tabs
    this.broadcastManager.notifyClose(id);

    // Send to background for cross-tab synchronization
    browser.runtime
      .sendMessage({
        action: 'CLOSE_QUICK_TAB',
        id
      })
      .catch(err =>
        console.error('[DestroyHandler] Failed to notify background:', err)
      );

    // Emit destruction event
    if (this.eventBus && this.Events) {
      this.eventBus.emit(this.Events.QUICK_TAB_DESTROYED, { id });
    }

    console.log('[DestroyHandler] Quick Tab destroyed:', id);
  }

  closeById(id) {
    const tab = this.quickTabsMap.get(id);
    if (!tab) return;

    // Call tab's own destroy method
    if (tab.destroy) {
      tab.destroy();
    }
  }

  closeAll() {
    console.log('[DestroyHandler] Closing all Quick Tabs');

    // Get all tab IDs before iteration (avoid modification during iteration)
    const tabIds = Array.from(this.quickTabsMap.keys());

    // Close each tab
    for (const id of tabIds) {
      this.closeById(id);
    }
  }
}
```

**Tests to Write:**

- Destroy removes from map
- Destroy removes from minimized manager
- Destroy broadcasts close message
- Destroy notifies background
- Destroy emits event
- CloseById calls tab.destroy()
- CloseAll destroys all tabs
- Handle non-existent tab ID gracefully

**Estimated Lines:** ~100 lines  
**Estimated Tests:** ~15 tests  
**Target Complexity:** cc <3

---

### Step 2: Extract Coordinators (2 files, ~250 lines total, ~35 tests)

Create directory: `src/features/quick-tabs/coordinators/`

#### 2.1 UICoordinator

**Responsibilities:**

- Render QuickTabWindow instances from QuickTab entities
- Update UI when state changes
- Handle minimized panel
- Manage QuickTabWindow lifecycle
- Listen to state events and trigger UI updates

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/coordinators/UICoordinator.js
export class UICoordinator {
  constructor(stateManager, minimizedManager, panelManager, eventBus) {
    this.stateManager = stateManager;
    this.minimizedManager = minimizedManager;
    this.panelManager = panelManager;
    this.eventBus = eventBus;
    this.renderedTabs = new Map(); // id -> QuickTabWindow
  }

  async init() {
    // Setup state listeners
    this.setupStateListeners();

    // Render initial state
    await this.renderAll();
  }

  async renderAll() {
    console.log('[UICoordinator] Rendering all visible tabs');

    // Get visible Quick Tabs from state
    const visibleTabs = this.stateManager.getVisible();

    // Render each tab
    for (const quickTab of visibleTabs) {
      this.render(quickTab);
    }
  }

  render(quickTab) {
    // Skip if already rendered
    if (this.renderedTabs.has(quickTab.id)) {
      console.log('[UICoordinator] Tab already rendered:', quickTab.id);
      return this.renderedTabs.get(quickTab.id);
    }

    // Create QuickTabWindow from QuickTab entity
    const tabWindow = createQuickTabWindow({
      id: quickTab.id,
      url: quickTab.url,
      left: quickTab.position.left,
      top: quickTab.position.top,
      width: quickTab.size.width,
      height: quickTab.size.height,
      title: quickTab.title,
      cookieStoreId: quickTab.container,
      minimized: quickTab.visibility.minimized,
      zIndex: quickTab.zIndex,
      soloedOnTabs: quickTab.visibility.soloedOnTabs,
      mutedOnTabs: quickTab.visibility.mutedOnTabs,
      // Callbacks are passed through from QuickTabsManager
      onDestroy: () => this.handleDestroy(quickTab.id),
      onMinimize: () => this.handleMinimize(quickTab.id),
      onFocus: () => this.handleFocus(quickTab.id)
      // ... other callbacks
    });

    this.renderedTabs.set(quickTab.id, tabWindow);
    console.log('[UICoordinator] Tab rendered:', quickTab.id);

    return tabWindow;
  }

  update(quickTab) {
    const tabWindow = this.renderedTabs.get(quickTab.id);
    if (!tabWindow) {
      console.warn(
        '[UICoordinator] Tab not rendered, rendering now:',
        quickTab.id
      );
      return this.render(quickTab);
    }

    // Update tab properties
    tabWindow.updatePosition(quickTab.position.left, quickTab.position.top);
    tabWindow.updateSize(quickTab.size.width, quickTab.size.height);
    tabWindow.updateZIndex(quickTab.zIndex);

    console.log('[UICoordinator] Tab updated:', quickTab.id);
  }

  destroy(quickTabId) {
    const tabWindow = this.renderedTabs.get(quickTabId);
    if (!tabWindow) return;

    // Call tab's destroy method
    if (tabWindow.destroy) {
      tabWindow.destroy();
    }

    this.renderedTabs.delete(quickTabId);
    console.log('[UICoordinator] Tab destroyed:', quickTabId);
  }

  setupStateListeners() {
    // Listen to state changes and trigger UI updates
    this.eventBus.on('state:added', ({ quickTab }) => {
      this.render(quickTab);
    });

    this.eventBus.on('state:updated', ({ quickTab }) => {
      this.update(quickTab);
    });

    this.eventBus.on('state:deleted', ({ id }) => {
      this.destroy(id);
    });
  }
}
```

**Tests to Write:**

- Render creates QuickTabWindow
- Update modifies existing window
- Destroy removes window
- RenderAll hydrates all visible tabs
- State listeners trigger UI updates
- Skip rendering already-rendered tabs
- Handle non-existent tab gracefully

**Estimated Lines:** ~120 lines  
**Estimated Tests:** ~18 tests  
**Target Complexity:** cc <3

---

#### 2.2 SyncCoordinator

**Responsibilities:**

- Coordinate storage ‚Üî state sync
- Handle broadcast messages from other tabs
- Route messages to appropriate handlers
- Resolve conflicts between local changes and remote broadcasts

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/coordinators/SyncCoordinator.js
export class SyncCoordinator {
  constructor(
    stateManager,
    storageManager,
    broadcastManager,
    handlers,
    eventBus
  ) {
    this.stateManager = stateManager;
    this.storageManager = storageManager;
    this.broadcastManager = broadcastManager;
    this.handlers = handlers; // { create, update, visibility, destroy }
    this.eventBus = eventBus;
  }

  setupListeners() {
    // Listen to storage changes
    this.eventBus.on('storage:changed', newValue => {
      this.handleStorageChange(newValue);
    });

    // Listen to broadcast messages
    this.eventBus.on('broadcast:received', ({ type, data }) => {
      this.handleBroadcastMessage(type, data);
    });
  }

  handleStorageChange(newValue) {
    console.log('[SyncCoordinator] Storage changed, syncing state');

    // Ignore changes from our own saves
    if (this.storageManager.shouldIgnoreStorageChange(newValue?.saveId)) {
      console.log('[SyncCoordinator] Ignoring own storage change');
      return;
    }

    // Sync state from storage
    // This will trigger state:added, state:updated, state:deleted events
    this.stateManager.hydrate(newValue.quickTabs);
  }

  handleBroadcastMessage(type, data) {
    console.log('[SyncCoordinator] Received broadcast:', type, data);

    // Route to appropriate handler
    switch (type) {
      case 'CREATE':
        this.handlers.create.create(data);
        break;

      case 'UPDATE_POSITION':
        this.handlers.update.handlePositionChangeEnd(
          data.id,
          data.left,
          data.top
        );
        break;

      case 'UPDATE_SIZE':
        this.handlers.update.handleSizeChangeEnd(
          data.id,
          data.width,
          data.height
        );
        break;

      case 'SOLO':
        this.handlers.visibility.handleSoloToggle(data.id, data.soloedOnTabs);
        break;

      case 'MUTE':
        this.handlers.visibility.handleMuteToggle(data.id, data.mutedOnTabs);
        break;

      case 'MINIMIZE':
        this.handlers.visibility.handleMinimize(data.id);
        break;

      case 'RESTORE':
        this.handlers.visibility.handleRestore(data.id);
        break;

      case 'CLOSE':
        this.handlers.destroy.handleDestroy(data.id);
        break;

      default:
        console.warn('[SyncCoordinator] Unknown broadcast type:', type);
    }
  }
}
```

**Tests to Write:**

- Storage changes sync to state
- Own storage changes are ignored
- Broadcast messages routed correctly to handlers
- CREATE message triggers create handler
- UPDATE_POSITION triggers update handler
- SOLO/MUTE trigger visibility handler
- CLOSE triggers destroy handler
- Unknown message types handled gracefully

**Estimated Lines:** ~100 lines  
**Estimated Tests:** ~17 tests  
**Target Complexity:** cc <3

---

### Step 3: Refactor QuickTabsManager as Facade (~200 lines)

**Goal:** Reduce QuickTabsManager from 1453 lines ‚Üí ~200 lines by delegating to
extracted components

**New Structure:**

```javascript
// src/features/quick-tabs/index.js (refactored)
import { StorageManager } from './managers/StorageManager.js';
import { BroadcastManager } from './managers/BroadcastManager.js';
import { StateManager } from './managers/StateManager.js';
import { EventManager } from './managers/EventManager.js';
import { CreateHandler } from './handlers/CreateHandler.js';
import { UpdateHandler } from './handlers/UpdateHandler.js';
import { VisibilityHandler } from './handlers/VisibilityHandler.js';
import { DestroyHandler } from './handlers/DestroyHandler.js';
import { UICoordinator } from './coordinators/UICoordinator.js';
import { SyncCoordinator } from './coordinators/SyncCoordinator.js';
import { MinimizedManager } from './minimized-manager.js';
import { PanelManager } from './panel.js';
import { CONSTANTS } from '../../core/config.js';
import { EventEmitter } from 'eventemitter3';

class QuickTabsManager {
  constructor() {
    this.tabs = new Map(); // Kept for backward compat
    this.currentZIndex = { value: CONSTANTS.QUICK_TAB_BASE_Z_INDEX }; // Changed to ref object
    this.initialized = false;
    this.cookieStoreId = null;
    this.currentTabId = null;

    // Internal event bus
    this.internalEventBus = new EventEmitter();

    // Managers (deferred init)
    this.storage = null;
    this.broadcast = null;
    this.state = null;
    this.events = null;

    // Handlers (deferred init)
    this.createHandler = null;
    this.updateHandler = null;
    this.visibilityHandler = null;
    this.destroyHandler = null;

    // Coordinators (deferred init)
    this.uiCoordinator = null;
    this.syncCoordinator = null;

    // Legacy UI managers
    this.minimizedManager = new MinimizedManager();
    this.panelManager = null;

    // Legacy fields for backward compat
    this.eventBus = null;
    this.Events = null;
  }

  async init(eventBus, Events) {
    if (this.initialized) {
      console.log('[QuickTabsManager] Already initialized, skipping');
      return;
    }

    this.eventBus = eventBus;
    this.Events = Events;

    console.log('[QuickTabsManager] Initializing facade...');

    // 1. Detect container and tab ID
    await this.detectContainerContext();
    await this.detectCurrentTabId();

    // 2. Initialize managers
    this.storage = new StorageManager(
      this.internalEventBus,
      this.cookieStoreId
    );
    this.broadcast = new BroadcastManager(
      this.internalEventBus,
      this.cookieStoreId
    );
    this.state = new StateManager(this.internalEventBus, this.currentTabId);
    this.events = new EventManager(this.internalEventBus, this.tabs);

    // 3. Initialize handlers
    this.createHandler = new CreateHandler(
      this.tabs,
      this.currentZIndex,
      this.cookieStoreId,
      this.broadcast,
      this.eventBus,
      this.Events,
      this.generateId.bind(this)
    );

    this.updateHandler = new UpdateHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.internalEventBus
    );

    this.visibilityHandler = new VisibilityHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.state,
      this.minimizedManager,
      this.internalEventBus
    );

    this.destroyHandler = new DestroyHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.minimizedManager,
      this.eventBus,
      this.Events
    );

    // 4. Initialize panel
    this.panelManager = new PanelManager(this);
    await this.panelManager.init();

    // 5. Initialize coordinators
    this.uiCoordinator = new UICoordinator(
      this.state,
      this.minimizedManager,
      this.panelManager,
      this.internalEventBus
    );

    this.syncCoordinator = new SyncCoordinator(
      this.state,
      this.storage,
      this.broadcast,
      {
        create: this.createHandler,
        update: this.updateHandler,
        visibility: this.visibilityHandler,
        destroy: this.destroyHandler
      },
      this.internalEventBus
    );

    // 6. Setup managers
    this.storage.setupStorageListeners();
    this.broadcast.setupBroadcastChannel();
    this.events.setupEmergencySaveHandlers();

    // 7. Setup coordinators
    this.syncCoordinator.setupListeners();
    await this.uiCoordinator.init();

    this.initialized = true;
    console.log('[QuickTabsManager] Facade initialized successfully');
  }

  // PUBLIC API - Delegate to handlers/coordinators

  createQuickTab(options) {
    // Add callbacks to options
    const optionsWithCallbacks = {
      ...options,
      onDestroy: tabId => this.handleDestroy(tabId),
      onMinimize: tabId => this.handleMinimize(tabId),
      onFocus: tabId => this.handleFocus(tabId),
      onPositionChange: (tabId, left, top) =>
        this.handlePositionChange(tabId, left, top),
      onPositionChangeEnd: (tabId, left, top) =>
        this.handlePositionChangeEnd(tabId, left, top),
      onSizeChange: (tabId, width, height) =>
        this.handleSizeChange(tabId, width, height),
      onSizeChangeEnd: (tabId, width, height) =>
        this.handleSizeChangeEnd(tabId, width, height),
      onSolo: (tabId, soloedOnTabs) =>
        this.handleSoloToggle(tabId, soloedOnTabs),
      onMute: (tabId, mutedOnTabs) => this.handleMuteToggle(tabId, mutedOnTabs)
    };

    const result = this.createHandler.create(optionsWithCallbacks);
    this.currentZIndex.value = result.newZIndex;
    return result.tabWindow;
  }

  handleDestroy(id) {
    return this.destroyHandler.handleDestroy(id);
  }

  handleMinimize(id) {
    return this.visibilityHandler.handleMinimize(id);
  }

  handleFocus(id) {
    return this.visibilityHandler.handleFocus(id);
  }

  handlePositionChange(id, left, top) {
    return this.updateHandler.handlePositionChange(id, left, top);
  }

  handlePositionChangeEnd(id, left, top) {
    return this.updateHandler.handlePositionChangeEnd(id, left, top);
  }

  handleSizeChange(id, width, height) {
    return this.updateHandler.handleSizeChange(id, width, height);
  }

  handleSizeChangeEnd(id, width, height) {
    return this.updateHandler.handleSizeChangeEnd(id, width, height);
  }

  handleSoloToggle(quickTabId, newSoloedTabs) {
    return this.visibilityHandler.handleSoloToggle(quickTabId, newSoloedTabs);
  }

  handleMuteToggle(quickTabId, newMutedTabs) {
    return this.visibilityHandler.handleMuteToggle(quickTabId, newMutedTabs);
  }

  closeById(id) {
    return this.destroyHandler.closeById(id);
  }

  closeAll() {
    return this.destroyHandler.closeAll();
  }

  // Keep existing utility methods
  async detectContainerContext() {
    /* existing implementation */
  }
  async detectCurrentTabId() {
    /* existing implementation */
  }
  generateId() {
    /* existing implementation */
  }
}

export { QuickTabsManager };
```

---

### Step 4: Testing & Validation

After all components extracted and facade integrated:

1. **Run All Unit Tests**

   ```bash
   npm run test:unit
   ```

2. **Run Integration Tests**

   ```bash
   npm run test:integration
   ```

3. **Validate Architecture**

   ```bash
   npm run validate:architecture
   ```

4. **Check Bundle Sizes**

   ```bash
   npm run build:check-size
   ```

5. **Manual Testing**
   - Create Quick Tab
   - Resize/drag
   - Solo/mute
   - Minimize/restore
   - Close
   - Cross-tab sync

---

## üß™ Testing Strategy (TDD Approach)

### For Each Component:

1. **Write tests FIRST** (TDD approach)

   ```bash
   touch tests/unit/handlers/UpdateHandler.test.js
   npm run test:unit -- UpdateHandler  # Should fail
   ```

2. **Extract component** from QuickTabsManager

   ```bash
   touch src/features/quick-tabs/handlers/UpdateHandler.js
   # Implement UpdateHandler
   ```

3. **Run tests** - verify 100% coverage

   ```bash
   npm run test:unit -- UpdateHandler  # Should pass
   ```

4. **Lint code** - ensure cc ‚â§ 9, depth ‚â§ 2

   ```bash
   npx eslint src/features/quick-tabs/handlers/UpdateHandler.js
   ```

5. **Commit** - separate commit per component
   ```bash
   git add src/features/quick-tabs/handlers/UpdateHandler.js tests/unit/handlers/UpdateHandler.test.js
   git commit -m "feat(refactor): Extract UpdateHandler from QuickTabsManager (2/6 components)"
   git push
   ```

---

## üìä Success Metrics

### Phase 2.1 Completion Criteria

- [ ] All 10 components extracted (5/10 done, 5/10 remaining)
- [ ] QuickTabsManager reduced to <400 lines (currently 1453 lines)
- [ ] All tests passing (currently 277, target 329+)
- [ ] Architecture validation passing
- [ ] Bundle sizes within limits (<500KB content.js)
- [ ] Mean CC < 3.5 (currently all new code < 3) ‚úÖ
- [ ] Zero ESLint errors
- [ ] All functionality preserved

### Current Progress vs. Target

| Metric                  | Current    | Target      | Progress |
| ----------------------- | ---------- | ----------- | -------- |
| QuickTabsManager size   | 1453 lines | <400 lines  | 0%       |
| Extracted code          | 1020 lines | ~1100 lines | 93%      |
| New managers/handlers   | 5          | 10          | 50%      |
| Tests                   | 277        | 329+        | 84%      |
| Mean CC (new code)      | <3         | <3.5        | ‚úÖ       |
| Architecture violations | 0          | 0           | ‚úÖ       |

---

## üîß How to Continue

### Recommended Order

1. **UpdateHandler** (lines 1209-1320) - **START HERE**
2. **VisibilityHandler** (lines 1044-1105, 1322-1420)
3. **DestroyHandler** (lines 994-1042, 1163-1207)
4. **UICoordinator** (new logic for QuickTabWindow rendering)
5. **SyncCoordinator** (new logic for message routing)
6. **Facade Integration** (refactor QuickTabsManager to use all components)
7. **Integration Testing** (verify no regressions)
8. **Update Documentation** (README, agent files)

### Commands Reference

```bash
# For each handler:
mkdir -p src/features/quick-tabs/handlers
touch src/features/quick-tabs/handlers/UpdateHandler.js
touch tests/unit/handlers/UpdateHandler.test.js

# Write tests first (TDD)
npm run test:unit -- UpdateHandler

# Implement handler
# ... write UpdateHandler.js ...

# Verify tests pass
npm run test:unit -- UpdateHandler

# Lint
npx eslint src/features/quick-tabs/handlers/UpdateHandler.js tests/unit/handlers/UpdateHandler.test.js

# Validate architecture
npm run validate:architecture

# Commit
git add src/features/quick-tabs/handlers/UpdateHandler.js tests/unit/handlers/UpdateHandler.test.js
git commit -m "feat(refactor): Extract UpdateHandler from QuickTabsManager (2/6 components)"
git push

# For coordinators:
mkdir -p src/features/quick-tabs/coordinators
# ... repeat same process ...
```

---

## üö® Important Notes for Next Agent

### DO NOT:

- ‚ùå Change existing QuickTabsManager until ALL handlers/coordinators are
  extracted
- ‚ùå Break backward compatibility
- ‚ùå Remove any existing functionality
- ‚ùå Modify Phase 1 code (domain/storage layers are COMPLETE)
- ‚ùå Change test infrastructure (already perfect)
- ‚ùå Skip writing tests before implementation

### DO:

- ‚úÖ Follow the extraction pattern used in CreateHandler
- ‚úÖ Write tests FIRST before extracting each component (TDD)
- ‚úÖ Use EventBus/EventEmitter for decoupled communication
- ‚úÖ Maintain 100% test coverage for each extracted component
- ‚úÖ Run tests frequently after each extraction
- ‚úÖ Keep cyclomatic complexity < 3 for all new code
- ‚úÖ Document integration points clearly
- ‚úÖ Commit after each component extraction
- ‚úÖ Use helper methods to reduce complexity (like CreateHandler)
- ‚úÖ Follow import order conventions (ESLint will enforce)

### Key Patterns to Follow

**1. Handler Constructor Pattern:**

```javascript
export class XyzHandler {
  constructor(quickTabsMap, ...otherDeps) {
    this.quickTabsMap = quickTabsMap;
    // ... other initialization
  }
}
```

**2. Event Emission Pattern:**

```javascript
this.eventBus?.emit('xyz:action', { data });
```

**3. Complexity Reduction Pattern:**

```javascript
// Main method should be simple orchestrator (cc ‚â§ 3)
publicMethod(options) {
  const result = this._doSomething(options);
  this._notifyOthers(result);
  return result;
}

// Extract helper methods (each cc ‚â§ 3)
_doSomething(options) { /* ... */ }
_notifyOthers(result) { /* ... */ }
```

**4. Container-Aware Pattern:**

```javascript
constructor(eventBus, cookieStoreId = 'firefox-default') {
  this.cookieStoreId = cookieStoreId;
  // Filter operations by container
}
```

---

## üìù Files Reference

### Created This Session

**Handlers:**

- `src/features/quick-tabs/handlers/CreateHandler.js`

**Tests:**

- `tests/unit/handlers/CreateHandler.test.js`

### Files to Create (Next Session)

**Handlers:**

- `src/features/quick-tabs/handlers/UpdateHandler.js`
- `src/features/quick-tabs/handlers/VisibilityHandler.js`
- `src/features/quick-tabs/handlers/DestroyHandler.js`

**Coordinators:**

- `src/features/quick-tabs/coordinators/UICoordinator.js`
- `src/features/quick-tabs/coordinators/SyncCoordinator.js`

**Tests:** (corresponding test files for each above)

### Files to Modify (Integration Phase)

- `src/features/quick-tabs/index.js` (QuickTabsManager - refactor as facade)

---

## üéØ Estimated Time Remaining

- UpdateHandler: 2 hours (test + implement + lint)
- VisibilityHandler: 3 hours (test + implement + lint)
- DestroyHandler: 2 hours (test + implement + lint)
- UICoordinator: 4 hours (test + implement + lint)
- SyncCoordinator: 3 hours (test + implement + lint)
- Facade Integration: 6 hours (refactor index.js, wire dependencies)
- Testing & Validation: 3 hours (integration tests, manual testing)
- Documentation: 2 hours (update README, agent files)

**Total: ~25 hours** (3-4 days for experienced developer)

---

## ‚úÖ Quality Gates

Before marking Phase 2.1 complete:

- [ ] All 10 components extracted (5/10 ‚úÖ + 5/10 remaining)
- [ ] QuickTabsManager reduced to <400 lines
- [ ] All tests passing (329+ tests)
- [ ] Zero ESLint errors
- [ ] Architecture validation passing
- [ ] Bundle sizes within limits
- [ ] Mean CC < 3.5
- [ ] All functionality preserved (manual testing)
- [ ] Documentation updated (README, agent files)

---

## üìö Key Documents to Reference

1. **Main Refactoring Plan:**
   `docs/manual/1.5.9 docs/copy-url-on-hover-refactoring-plan-v2-evidence-based.md`
2. **Infrastructure Plan:**
   `docs/manual/1.5.9 docs/infrastructure-testing-changes-refactoring.md`
3. **Phase 2.1 Previous Handoff:**
   `docs/misc/v1.6.0-REFACTORING-PHASE2.1-HANDOFF.md`
4. **Phase 1 Complete Summary:**
   `docs/misc/v1.6.0-REFACTORING-PHASE1-COMPLETE.md`

---

## üîç Code Locations Quick Reference

### QuickTabsManager (index.js) - Lines to Extract:

- **UpdateHandler:**
  - `handlePositionChange` - Lines 1209-1219
  - `handlePositionChangeEnd` - Lines 1221-1265
  - `handleSizeChange` - Lines 1267-1278
  - `handleSizeChangeEnd` - Lines 1280-1320

- **VisibilityHandler:**
  - `handleSoloToggle` - Lines 1322-1371
  - `handleMuteToggle` - Lines 1373-1420
  - `handleMinimize` - Lines 1044-1087
  - `handleFocus` - Lines 1089-1105

- **DestroyHandler:**
  - `handleDestroy` - Lines 994-1042
  - `closeById` - Lines 1163-1171
  - `closeAll` - Lines 1194-1207

### Utility Methods to Keep in Facade:

- `detectContainerContext()` - Lines 107-147
- `detectCurrentTabId()` - Lines 149-188
- `generateId()` - Lines 190-194
- `setupMessageListeners()` - Lines 1422-1453 (will be refactored but kept)

---

**Good luck with the remaining handlers and coordinators!** The hardest
architectural work is done. This is now systematic extraction following the
established pattern. You've got this! üöÄ

---

## üß© Integration Points Summary

### Managers ‚Üí Handlers

- **StorageManager** used by: UpdateHandler, VisibilityHandler, DestroyHandler
- **BroadcastManager** used by: CreateHandler, UpdateHandler, VisibilityHandler,
  DestroyHandler
- **StateManager** used by: VisibilityHandler, UICoordinator, SyncCoordinator
- **EventManager** used by: QuickTabsManager facade (emergency saves)

### Handlers ‚Üí Coordinators

- **CreateHandler** used by: SyncCoordinator (routing broadcast messages)
- **UpdateHandler** used by: SyncCoordinator (routing broadcast messages)
- **VisibilityHandler** used by: SyncCoordinator (routing broadcast messages)
- **DestroyHandler** used by: SyncCoordinator (routing broadcast messages)

### Coordinators ‚Üí Facade

- **UICoordinator** orchestrates: QuickTabWindow rendering, state ‚Üí UI sync
- **SyncCoordinator** orchestrates: Storage ‚Üî state, broadcast ‚Üí handlers

This ensures clean separation of concerns with unidirectional data flow.

---

## üìñ Helpful Tips

### When Extracting Methods:

1. **Keep original method signatures** - don't break callers
2. **Extract to private methods first** (\_methodName) - reduce complexity
3. **Use helper methods liberally** - each method should do ONE thing
4. **Comment why, not what** - code should be self-documenting
5. **Keep event emissions explicit** - makes debugging easier

### When Writing Tests:

1. **Test behavior, not implementation** - test what, not how
2. **One assertion per test** - easier to debug failures
3. **Use descriptive test names** - should read like documentation
4. **Mock at boundaries** - mock external dependencies only
5. **Test error cases** - happy path + edge cases + errors

### When Reducing Complexity:

1. **Extract conditional logic** - if/else ‚Üí separate methods
2. **Use early returns** - reduce nesting depth
3. **Use guard clauses** - fail fast
4. **Extract loops** - forEach/map/filter instead of for loops
5. **One level of abstraction** - don't mix high/low level code

---

END OF HANDOFF DOCUMENT
