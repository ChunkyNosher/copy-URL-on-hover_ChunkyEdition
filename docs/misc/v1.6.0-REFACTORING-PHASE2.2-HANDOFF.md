# v1.6.0 Refactoring - Phase 2.2 Handoff Document

**Date:** 2025-11-18  
**Agent:** refactor-specialist  
**Status:** Phase 2.2 - IN PROGRESS (ESLint cleanup complete, facade integration next)  
**Next Agent:** Continue with QuickTabsManager facade integration

---

## ðŸŽ¯ Current Status Summary

### âœ… Completed Work This Session

**1. ESLint Error Fixes (Refactored Code)**
- Fixed 5 files with complexity and nesting violations
- Reduced from 9 files with errors to 4 files
- All refactored components now pass ESLint

**Files Fixed:**
1. **src/features/url-handlers/generic.js**
   - Extracted `isLinkContainer()` helper
   - Complexity: 10 â†’ 2 âœ…
   
2. **src/storage/SyncStorageAdapter.js**
   - Extracted `_handleSaveError()` method
   - Max-depth: 3 â†’ 2 âœ…
   
3. **src/utils/debug.js**
   - Extracted `_fetchBackgroundLogs()`
   - Extracted `_tryBrowserDownloadsAPI()`
   - Extracted `_downloadViaBlob()`
   - Max-depth: 3 â†’ 2 (2 instances) âœ…
   
4. **src/domain/QuickTab.js**
   - Extracted `_validateString()`
   - Extracted `_validatePosition()`
   - Extracted `_validateSize()`
   - Constructor complexity: 15 â†’ 3 âœ…
   
5. **src/features/quick-tabs/managers/BroadcastManager.js**
   - Extracted `_cleanupOldDebounceEntries()`
   - Removed unnecessary `async` from `broadcast()`
   - Max-depth: 3 â†’ 2 âœ…

**Test Results:**
- âœ… All 410 unit tests passing
- âœ… Zero errors in fixed files
- âœ… Build successful

---

## ðŸš§ Remaining Work

### **Step 2: Fix ESLint Errors in Pre-Refactoring Code**

**Files with Errors (47 errors total):**
1. **src/content.js** - 17 errors
2. **src/features/quick-tabs/index.js** - 19 errors
3. **src/features/quick-tabs/panel.js** - 5 errors
4. **src/features/quick-tabs/window.js** - 6 errors

**Note:** Many of these errors will be automatically fixed when we refactor index.js into the facade pattern. The errors are in code that will be removed or heavily refactored.

**Recommendation:** Start facade integration immediately. Address remaining errors only if they block the refactoring.

---

### **Step 3: QuickTabsManager Facade Integration (CRITICAL)**

**Goal:** Refactor `src/features/quick-tabs/index.js` from 1453 lines to ~400 lines

**Current State:**
- File: `src/features/quick-tabs/index.js`
- Size: 1453 lines
- Mean CC: 6.74
- Max CC: 25
- ESLint errors: 19 (many will be removed during refactor)

**Target State:**
- Size: ~400 lines
- Mean CC: <3.5
- Max CC: <9
- ESLint errors: 0

---

## ðŸ“‹ Facade Integration Implementation Plan

Based on `docs/misc/v1.6.0-REFACTORING-PHASE2.1-COMPLETE-HANDOFF.md` (lines 150-462)

### Part A: Analyze Current index.js (~2 hours)

**Read the entire file and categorize code:**

**Code to KEEP (utility methods):**
- âœ… `constructor()` - Will be simplified
- âœ… `detectContainerContext()` - async, uses browser.tabs
- âœ… `detectCurrentTabId()` - async, uses browser.runtime.sendMessage
- âœ… `generateId()` - pure utility
- âœ… `generateSaveId()` - pure utility
- âœ… `trackPendingSave(saveId)` - state tracking
- âœ… `releasePendingSave(saveId)` - state tracking

**Code to REMOVE (now in extracted components):**
- âŒ Storage methods â†’ StorageManager
  - `setupStorageListeners()`
  - `syncFromStorage()`
  - `hydrateStateFromStorage()`
  - `saveCurrentStateToBackground()`
  
- âŒ Broadcast methods â†’ BroadcastManager
  - `setupBroadcastChannel()`
  - `handleSoloFromBroadcast()`
  - `handleMuteFromBroadcast()`
  
- âŒ State methods â†’ StateManager
  - State tracking logic
  
- âŒ Event methods â†’ EventManager
  - `setupMessageListeners()`
  - `setupEmergencySaveHandlers()`
  
- âŒ Create logic â†’ CreateHandler
- âŒ Update logic â†’ UpdateHandler
- âŒ Visibility logic â†’ VisibilityHandler
- âŒ Destroy logic â†’ DestroyHandler
- âŒ UI coordination â†’ UICoordinator
- âŒ Sync coordination â†’ SyncCoordinator

**Code to REFACTOR (delegation):**
- Public API methods â†’ delegate to handlers
- Initialization â†’ wire all components

---

### Part B: Create Facade Structure (~3 hours)

**New facade template (based on handoff document):**

```javascript
// src/features/quick-tabs/index.js (refactored)
import { StorageManager } from './managers/StorageManager.js';
import { BroadcastManager } from './managers/BroadcastManager.js';
import { StateManager } from './managers/StateManager.js';
import { EventManager } from './managers/EventManager.js';
import { CreateHandler } from './handlers/CreateHandler.js';
import { UpdateHandler } from './handlers/UpdateHandler.js';
import { VisibilityHandler } from './handlers/VisibilityHandler.js';
import { DestroyHandler } from './handlers/DestroyHandler.js';
import { UICoordinator } from './coordinators/UICoordinator.js';
import { SyncCoordinator } from './coordinators/SyncCoordinator.js';
import { MinimizedManager } from './minimized-manager.js';
import { PanelManager } from './panel.js';
import { CONSTANTS } from '../../core/config.js';
import { EventEmitter } from 'eventemitter3';

class QuickTabsManager {
  constructor() {
    // Backward compat fields
    this.tabs = new Map(); // Kept for legacy references
    this.currentZIndex = { value: CONSTANTS.QUICK_TAB_BASE_Z_INDEX }; // Changed to ref object
    this.initialized = false;
    this.cookieStoreId = null;
    this.currentTabId = null;
    this.pendingSaves = new Set(); // For saveId tracking

    // Internal event bus (NEW)
    this.internalEventBus = new EventEmitter();

    // Managers (deferred init)
    this.storage = null;
    this.broadcast = null;
    this.state = null;
    this.events = null;

    // Handlers (deferred init)
    this.createHandler = null;
    this.updateHandler = null;
    this.visibilityHandler = null;
    this.destroyHandler = null;

    // Coordinators (deferred init)
    this.uiCoordinator = null;
    this.syncCoordinator = null;

    // Legacy UI managers
    this.minimizedManager = new MinimizedManager();
    this.panelManager = null;

    // Legacy fields for backward compat
    this.eventBus = null;
    this.Events = null;
  }

  async init(eventBus, Events) {
    if (this.initialized) {
      console.log('[QuickTabsManager] Already initialized, skipping');
      return;
    }

    this.eventBus = eventBus;
    this.Events = Events;

    console.log('[QuickTabsManager] Initializing facade...');

    // 1. Detect container and tab ID
    await this.detectContainerContext();
    await this.detectCurrentTabId();

    // 2. Initialize managers
    this.storage = new StorageManager(this.internalEventBus, this.cookieStoreId);
    this.broadcast = new BroadcastManager(this.internalEventBus, this.cookieStoreId);
    this.state = new StateManager(this.internalEventBus, this.currentTabId);
    this.events = new EventManager(this.internalEventBus, this.tabs);

    // 3. Initialize handlers
    this.createHandler = new CreateHandler(
      this.tabs,
      this.currentZIndex,
      this.cookieStoreId,
      this.broadcast,
      this.eventBus,
      this.Events,
      this.generateId.bind(this)
    );

    this.updateHandler = new UpdateHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.internalEventBus,
      this.generateSaveId.bind(this),
      this.releasePendingSave.bind(this)
    );

    this.visibilityHandler = new VisibilityHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.minimizedManager,
      this.internalEventBus,
      this.currentZIndex,
      this.generateSaveId.bind(this),
      this.trackPendingSave.bind(this),
      this.releasePendingSave.bind(this),
      this.currentTabId,
      this.Events
    );

    this.destroyHandler = new DestroyHandler(
      this.tabs,
      this.broadcast,
      this.minimizedManager,
      this.eventBus,
      this.currentZIndex,
      this.generateSaveId.bind(this),
      this.releasePendingSave.bind(this),
      this.Events,
      CONSTANTS.QUICK_TAB_BASE_Z_INDEX
    );

    // 4. Initialize panel
    this.panelManager = new PanelManager(this);
    await this.panelManager.init();

    // 5. Initialize coordinators
    this.uiCoordinator = new UICoordinator(
      this.state,
      this.minimizedManager,
      this.panelManager,
      this.internalEventBus
    );

    this.syncCoordinator = new SyncCoordinator(
      this.state,
      this.storage,
      this.broadcast,
      {
        create: this.createHandler,
        update: this.updateHandler,
        visibility: this.visibilityHandler,
        destroy: this.destroyHandler
      },
      this.internalEventBus
    );

    // 6. Setup managers
    this.storage.setupStorageListeners();
    this.broadcast.setupBroadcastChannel();
    this.events.setupEmergencySaveHandlers();

    // 7. Setup coordinators
    this.syncCoordinator.setupListeners();
    await this.uiCoordinator.init();

    this.initialized = true;
    console.log('[QuickTabsManager] Facade initialized successfully');
  }

  // PUBLIC API - Delegate to handlers/coordinators

  createQuickTab(options) {
    // Add callbacks to options
    const optionsWithCallbacks = {
      ...options,
      onDestroy: tabId => this.handleDestroy(tabId),
      onMinimize: tabId => this.handleMinimize(tabId),
      onFocus: tabId => this.handleFocus(tabId),
      onPositionChange: (tabId, left, top) => this.handlePositionChange(tabId, left, top),
      onPositionChangeEnd: (tabId, left, top) => this.handlePositionChangeEnd(tabId, left, top),
      onSizeChange: (tabId, width, height) => this.handleSizeChange(tabId, width, height),
      onSizeChangeEnd: (tabId, width, height) => this.handleSizeChangeEnd(tabId, width, height),
      onSolo: (tabId, soloedOnTabs) => this.handleSoloToggle(tabId, soloedOnTabs),
      onMute: (tabId, mutedOnTabs) => this.handleMuteToggle(tabId, mutedOnTabs)
    };

    const result = this.createHandler.create(optionsWithCallbacks);
    this.currentZIndex.value = result.newZIndex;
    return result.tabWindow;
  }

  handleDestroy(id) {
    return this.destroyHandler.handleDestroy(id);
  }

  handleMinimize(id) {
    return this.visibilityHandler.handleMinimize(id);
  }

  handleFocus(id) {
    return this.visibilityHandler.handleFocus(id);
  }

  handlePositionChange(id, left, top) {
    return this.updateHandler.handlePositionChange(id, left, top);
  }

  handlePositionChangeEnd(id, left, top) {
    return this.updateHandler.handlePositionChangeEnd(id, left, top);
  }

  handleSizeChange(id, width, height) {
    return this.updateHandler.handleSizeChange(id, width, height);
  }

  handleSizeChangeEnd(id, width, height) {
    return this.updateHandler.handleSizeChangeEnd(id, width, height);
  }

  handleSoloToggle(quickTabId, newSoloedTabs) {
    return this.visibilityHandler.handleSoloToggle(quickTabId, newSoloedTabs);
  }

  handleMuteToggle(quickTabId, newMutedTabs) {
    return this.visibilityHandler.handleMuteToggle(quickTabId, newMutedTabs);
  }

  closeById(id) {
    return this.destroyHandler.closeById(id);
  }

  closeAll() {
    return this.destroyHandler.closeAll();
  }

  // Utility methods (KEEP THESE)

  async detectContainerContext() {
    try {
      const tabs = await browser.tabs.query({ active: true, currentWindow: true });
      if (tabs.length > 0 && tabs[0].cookieStoreId) {
        this.cookieStoreId = tabs[0].cookieStoreId;
        console.log('[QuickTabsManager] Detected container:', this.cookieStoreId);
      } else {
        this.cookieStoreId = 'firefox-default';
        console.log('[QuickTabsManager] Using default container');
      }
    } catch (err) {
      console.error('[QuickTabsManager] Failed to detect container:', err);
      this.cookieStoreId = 'firefox-default';
    }
  }

  async detectCurrentTabId() {
    try {
      const response = await browser.runtime.sendMessage({ action: 'GET_CURRENT_TAB_ID' });
      if (response && response.tabId) {
        this.currentTabId = response.tabId;
        console.log('[QuickTabsManager] Detected current tab ID:', this.currentTabId);
      }
    } catch (err) {
      console.error('[QuickTabsManager] Failed to detect tab ID:', err);
    }
  }

  generateId() {
    return `qt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  generateSaveId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  trackPendingSave(saveId) {
    this.pendingSaves.add(saveId);
    console.log('[QuickTabsManager] Tracking pending save:', saveId);
  }

  releasePendingSave(saveId) {
    this.pendingSaves.delete(saveId);
    console.log('[QuickTabsManager] Released pending save:', saveId);
  }
}

export { QuickTabsManager };
```

---

### Part C: Implementation Steps

**Step 1: Create backup (~5 minutes)**
```bash
cp src/features/quick-tabs/index.js src/features/quick-tabs/index.js.backup
```

**Step 2: Replace with facade template (~30 minutes)**
- Copy the template above into index.js
- Verify all imports are correct
- Check that all component paths exist

**Step 3: Test build (~15 minutes)**
```bash
npm run build
# Should compile successfully
```

**Step 4: Test unit tests (~15 minutes)**
```bash
npm run test:unit
# All 410 tests should pass
```

**Step 5: Manual testing (~1 hour)**
Load extension in Firefox and test:
- [ ] Create Quick Tab (Alt+Shift+Q)
- [ ] Verify rendering
- [ ] Drag to move
- [ ] Resize
- [ ] Solo button
- [ ] Mute button
- [ ] Minimize/Restore
- [ ] Close button
- [ ] Cross-tab sync (open same URL in 2 tabs)
- [ ] Container isolation (create Quick Tab in container, verify not visible in default)

**Step 6: Fix any integration issues (~2 hours)**
- Debug any errors found during manual testing
- Adjust wiring if needed
- Ensure all callbacks work correctly

---

## ðŸŽ¯ Success Criteria

After facade integration is complete:

- [ ] `index.js` size: ~400 lines (from 1453)
- [ ] Mean CC: <3.5 (from 6.74)
- [ ] Max CC: <9 (from 25)
- [ ] All 410 unit tests passing
- [ ] Zero ESLint errors
- [ ] All functionality preserved:
  - [ ] Create Quick Tab
  - [ ] Drag to reposition
  - [ ] Resize
  - [ ] Solo/Mute
  - [ ] Minimize/Restore
  - [ ] Close
  - [ ] Cross-tab sync
  - [ ] Container isolation

---

## ðŸ“Š Metrics Tracking

### Before Refactoring (v1.5.9)
| Metric | Value |
|--------|-------|
| index.js size | 1453 lines |
| Mean CC | 6.74 |
| Max CC | 25 |
| Large functions (>70 LOC) | 8 |
| Test coverage | ~40% |
| Tests | 90 |

### After Phase 2.1 (Current)
| Metric | Value |
|--------|-------|
| Components extracted | 10 |
| New test coverage | 100% |
| New tests | 410 |
| ESLint errors (new code) | 0 |

### Target After Phase 2.2
| Metric | Value |
|--------|-------|
| index.js size | ~400 lines |
| Mean CC | <3.5 |
| Max CC | <9 |
| Large functions | 0 |
| ESLint errors | 0 |

---

## ðŸš¨ Critical Notes for Next Agent

### DO NOT:
- âŒ Change any existing extracted components (they're complete and tested)
- âŒ Break backward compatibility
- âŒ Remove functionality
- âŒ Skip testing
- âŒ Skip documentation updates
- âŒ Modify this.tabs Map structure (other code depends on it)

### DO:
- âœ… Follow the facade integration plan exactly
- âœ… Test frequently after each change
- âœ… Preserve all utility methods
- âœ… Keep backward compat fields (this.tabs, this.eventBus)
- âœ… Wire all components correctly
- âœ… Delegate methods properly
- âœ… Update all documentation after completion
- âœ… Create Phase 2.3 handoff document

### Key Integration Points

**Component dependencies flow:**
```
QuickTabsManager (Facade)
â”œâ”€â”€ Managers
â”‚   â”œâ”€â”€ StorageManager (uses: eventBus, cookieStoreId)
â”‚   â”œâ”€â”€ BroadcastManager (uses: eventBus, cookieStoreId)
â”‚   â”œâ”€â”€ StateManager (uses: eventBus, currentTabId)
â”‚   â””â”€â”€ EventManager (uses: eventBus, tabs Map)
â”œâ”€â”€ Handlers
â”‚   â”œâ”€â”€ CreateHandler (uses: tabs, zIndex, broadcast, eventBus)
â”‚   â”œâ”€â”€ UpdateHandler (uses: tabs, broadcast, storage, eventBus)
â”‚   â”œâ”€â”€ VisibilityHandler (uses: tabs, broadcast, storage, minimized)
â”‚   â””â”€â”€ DestroyHandler (uses: tabs, broadcast, minimized, eventBus)
â””â”€â”€ Coordinators
    â”œâ”€â”€ UICoordinator (uses: state, minimized, panel, eventBus)
    â””â”€â”€ SyncCoordinator (uses: state, storage, broadcast, handlers, eventBus)
```

**Event flows:**

1. **Storage changes:**
   - StorageManager emits `storage:changed` on eventBus
   - SyncCoordinator listens and calls StateManager.hydrate()
   - StateManager emits `state:added/updated/deleted`
   - UICoordinator listens and updates UI

2. **Broadcast messages:**
   - BroadcastManager emits `broadcast:received` on eventBus
   - SyncCoordinator listens and routes to appropriate handler
   - Handler updates state
   - State changes trigger UI updates

3. **User actions:**
   - QuickTabWindow fires callback (e.g., onDestroy)
   - Facade delegates to handler (e.g., DestroyHandler.handleDestroy())
   - Handler updates state, broadcasts, and saves
   - Other tabs receive broadcast and update

---

## ðŸ“š Reference Documents

1. **Main refactoring plan:** `docs/manual/1.5.9 docs/copy-url-on-hover-refactoring-plan-v2-evidence-based.md`
2. **Infrastructure plan:** `docs/manual/1.5.9 docs/infrastructure-testing-changes-refactoring.md`
3. **Phase 1 complete:** `docs/misc/v1.6.0-REFACTORING-PHASE1-COMPLETE.md`
4. **Phase 2.1 complete:** `docs/misc/v1.6.0-REFACTORING-PHASE2.1-COMPLETE-HANDOFF.md`

---

## ðŸ•’ Time Estimates

| Task | Estimated Time |
|------|----------------|
| Analyze current index.js | 2 hours |
| Create facade structure | 3 hours |
| Test integration | 3 hours |
| Fix integration issues | 2 hours |
| Documentation updates | 2 hours |
| **Total** | **~12 hours** |

---

## ðŸ Completion Checklist

When facade integration is complete:

- [ ] index.js refactored to facade pattern
- [ ] All 410 unit tests passing
- [ ] Manual testing completed successfully
- [ ] Zero ESLint errors
- [ ] Build successful
- [ ] README.md updated with v1.6.0 changes
- [ ] All Copilot agent files updated
- [ ] Phase 2.2 completion summary created
- [ ] Phase 2.3 handoff document created

---

## ðŸŽ‰ What's Next: Phase 2.3

After facade integration is complete, Phase 2.3 will focus on:

1. **window.js decomposition** (if time permits)
   - Extract ResizeController
   - Extract ResizeHandle classes
   - Extract DragController
   - Extract TitlebarBuilder

2. **panel.js cleanup** (if needed)
   - Fix remaining ESLint errors
   - Extract components if beneficial

3. **content.js cleanup** (if needed)
   - Fix remaining ESLint errors
   - Apply command pattern for keyboard shortcuts

4. **Final cleanup and optimization**
   - Remove any dead code
   - Optimize imports
   - Final ESLint pass
   - Bundle size check

---

## END OF HANDOFF DOCUMENT

**Good luck with the facade integration! This is the home stretch of the refactoring.** ðŸš€
