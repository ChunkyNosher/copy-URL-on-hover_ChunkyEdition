# v1.6.0 Refactoring - Phase 2.1 Handoff Document

**Date:** 2025-11-18  
**Agent:** refactor-specialist  
**Status:** Phase 2.1 In Progress - 4 of 10 Components Complete (40%)  
**Next Agent:** Continue handler/coordinator extraction and facade integration

---

## üéØ Executive Summary

**Phase 2.1 Goal:** Decompose QuickTabsManager god object (1453 lines ‚Üí ~400 lines facade)

**Current Progress:**

- ‚úÖ **4 managers extracted** (StorageManager, BroadcastManager, StateManager, EventManager)
- ‚úÖ **850 lines extracted** (58% of target reduction)
- ‚úÖ **103 new tests added** (all passing, 100% coverage for extracted code)
- ‚è≥ **6 components remaining** (4 Handlers + 2 Coordinators + Facade Integration)

---

## ‚úÖ Completed Work

### Infrastructure (COMPLETE - Previous Agent)

All infrastructure updates from `infrastructure-testing-changes-refactoring.md` are COMPLETE:

- ‚úÖ **Rollup config** - Module aliases (@domain, @storage, @features, @utils, @core, @ui)
- ‚úÖ **Jest config** - Coverage thresholds by layer (domain=100%, storage=90%, features=80%)
- ‚úÖ **ESLint rules** - Complexity limits (cc‚â§9, depth‚â§2, lines‚â§70), architecture boundaries
- ‚úÖ **npm scripts** - test:unit, test:domain, validate:architecture, build:check-size, etc.
- ‚úÖ **Test helpers** - test-builders.js, async-helpers.js, dom-helpers.js
- ‚úÖ **Mocks** - webextension-polyfill, browser-storage, broadcast-channel
- ‚úÖ **Scripts** - validate-architecture.js, check-bundle-size.js

### Phase 1 (COMPLETE - Previous Agent)

- ‚úÖ **QuickTab domain entity** (207 lines, 74 tests, 100% coverage)
- ‚úÖ **Container domain entity** (203 lines, 43 tests, 100% coverage)
- ‚úÖ **SyncStorageAdapter** (238 lines, 19 tests)
- ‚úÖ **SessionStorageAdapter** (183 lines, 13 tests)
- ‚úÖ **FormatMigrator** (164 lines, 31 tests)

### Phase 2.1 - Managers (4/7 COMPLETE)

#### 1. StorageManager ‚úÖ (279 lines, 25 tests)

**File:** `src/features/quick-tabs/managers/StorageManager.js`  
**Tests:** `tests/unit/managers/StorageManager.test.js`

**Responsibilities:**

- Save/load Quick Tabs via SyncStorageAdapter and SessionStorageAdapter
- Container-aware storage operations
- Race condition prevention via saveId tracking
- Debounced storage sync (100ms)

**Key Methods:**

- `save(quickTabs)` - Save array of QuickTab entities
- `loadAll()` - Load all Quick Tabs for current container
- `setupStorageListeners()` - Listen for storage changes
- `delete(quickTabId)` - Delete specific Quick Tab

**Events Emitted:**

- `storage:saved`, `storage:changed`, `storage:deleted`, `storage:cleared`, `storage:error`

---

#### 2. BroadcastManager ‚úÖ (227 lines, 27 tests)

**File:** `src/features/quick-tabs/managers/BroadcastManager.js`

**Tests:** `tests/unit/managers/BroadcastManager.test.js`

**Responsibilities:**

- Cross-tab messaging via BroadcastChannel

- Container-specific channel isolation
- Message debouncing (50ms)

**Key Methods:**

- `setupBroadcastChannel()` - Create container-specific channel
- `broadcast(type, data)` - Send message to other tabs
- `notifyCreate/PositionUpdate/SizeUpdate/Minimize/Restore/Close/Solo/Mute()`

**Events Emitted:**

- `broadcast:received` with `{ type, data }`

---

#### 3. StateManager ‚úÖ (251 lines, 34 tests)

**File:** `src/features/quick-tabs/managers/StateManager.js`  
**Tests:** `tests/unit/managers/StateManager.test.js`

**Responsibilities:**

- Manage local in-memory state (Map<id, QuickTab>)
- Visibility filtering (solo/mute)
- Z-index management
- Dead tab cleanup

**Key Methods:**

- `add/get/update/delete/getAll/getVisible/getMinimized()`
- `hydrate(quickTabs)` - Bulk load from storage
- `setCurrentTabId(tabId)` - For visibility filtering
- `cleanupDeadTabs(activeTabIds)` - Remove dead tab IDs

**Events Emitted:**

- `state:added`, `state:updated`, `state:deleted`, `state:hydrated`, `state:cleared`, `state:z-index-changed`, `state:cleaned`

---

#### 4. EventManager ‚úÖ (93 lines, 17 tests) - NEW THIS SESSION

**File:** `src/features/quick-tabs/managers/EventManager.js`  
**Tests:** `tests/unit/managers/EventManager.test.js`

**Responsibilities:**

- Emergency save handlers (visibilitychange, beforeunload, pagehide)
- Window event coordination
- Cleanup on teardown

**Key Methods:**

- `setupEmergencySaveHandlers()` - Attach DOM listeners
- `teardown()` - Remove all listeners

**Events Emitted:**

- `event:emergency-save` with `{ trigger }`

---

## üìã Remaining Work for Phase 2.1

### Step 1: Extract Handlers (4 files, ~400 lines total, ~50 tests)

Create directory: `src/features/quick-tabs/handlers/`

#### 1.1 CreateHandler

**Extract from QuickTabsManager:**

- `createQuickTab(options)` - Lines 903-992

**Responsibilities:**

- Validate options
- Generate ID if not provided
- Auto-assign container
- Create QuickTabWindow instance
- Store in tabs Map
- Broadcast CREATE message
- Emit QUICK_TAB_CREATED event

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/CreateHandler.js
export class CreateHandler {
  constructor(quickTabsMap, currentZIndex, cookieStoreId, broadcastManager, eventBus, Events) {
    this.quickTabsMap = quickTabsMap;

    this.currentZIndex = currentZIndex;
    this.cookieStoreId = cookieStoreId;
    this.broadcastManager = broadcastManager;
    this.eventBus = eventBus;
    this.Events = Events;
  }

  create(options) {
    // Extract logic from createQuickTab()
    // Return { tabWindow, newZIndex }
  }
}
```

**Tests:**

- Create with all options
- Create with minimal options (use defaults)
- Generate ID when not provided
- Auto-assign container

- Check duplicate ID handling
- Verify broadcast sent
- Verify event emitted
- Verify z-index incremented

---

#### 1.2 UpdateHandler

**Extract from QuickTabsManager:**

- `handlePositionChange(id, left, top)` - Lines 1209-1219
- `handlePositionChangeEnd(id, left, top)` - Lines 1221-1265
- `handleSizeChange(id, width, height)` - Lines 1267-1278
- `handleSizeChangeEnd(id, width, height)` - Lines 1280-1320

**Responsibilities:**

- Handle position updates (drag)
- Handle size updates (resize)
- Debounced broadcasting
- Save to storage on change end

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/UpdateHandler.js
export class UpdateHandler {
  constructor(quickTabsMap, broadcastManager, storageManager, eventBus) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;
    this.eventBus = eventBus;
    this.debouncers = new Map(); // For debounced saves
  }

  handlePositionChange(id, left, top) {
    // Update tab position immediately (no save/broadcast)
  }

  handlePositionChangeEnd(id, left, top) {
    // Update, save, broadcast
  }

  handleSizeChange(id, width, height) {
    // Update tab size immediately (no save/broadcast)
  }

  handleSizeChangeEnd(id, width, height) {
    // Update, save, broadcast
  }
}
```

**Tests:**

- Position change (no broadcast/save)
- Position change end (broadcast + save)
- Size change (no broadcast/save)
- Size change end (broadcast + save)

- Debouncing behavior
- Error handling

---

#### 1.3 VisibilityHandler

**Extract from QuickTabsManager:**

- `handleSoloToggle(quickTabId, newSoloedTabs)` - Lines 1322-1371
- `handleMuteToggle(quickTabId, newMutedTabs)` - Lines 1373-1420
- `handleMinimize(id)` - Lines 1044-1087
- `handleFocus(id)` - Lines 1089-1105

**Responsibilities:**

- Solo/mute toggle logic
- Minimize/restore logic
- Focus management
- Broadcast visibility changes

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/VisibilityHandler.js
export class VisibilityHandler {
  constructor(quickTabsMap, broadcastManager, storageManager, stateManager, eventBus) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;

    this.stateManager = stateManager;
    this.eventBus = eventBus;
  }

  handleSoloToggle(quickTabId, newSoloedTabs) {
    // Update solo state, save, broadcast
  }

  handleMuteToggle(quickTabId, newMutedTabs) {
    // Update mute state, save, broadcast
  }

  handleMinimize(id) {
    // Minimize tab, save, broadcast
  }

  handleFocus(id) {
    // Bring to front, update z-index
  }
}
```

**Tests:**

- Solo toggle adds/removes tabs

- Mute toggle adds/removes tabs
- Minimize updates state
- Restore from minimized
- Focus brings to front
- Broadcast messages sent
- Storage saved

---

#### 1.4 DestroyHandler

**Extract from QuickTabsManager:**

- `handleDestroy(id)` - Lines 994-1042
- `closeById(id)` - Lines 1163-1171
- `closeAll()` - Lines 1194-1207

**Responsibilities:**

- Close single Quick Tab
- Close all Quick Tabs
- Cleanup DOM
- Remove from state
- Broadcast close message

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/handlers/DestroyHandler.js
export class DestroyHandler {
  constructor(quickTabsMap, broadcastManager, storageManager, minimizedManager, eventBus, Events) {
    this.quickTabsMap = quickTabsMap;
    this.broadcastManager = broadcastManager;
    this.storageManager = storageManager;
    this.minimizedManager = minimizedManager;
    this.eventBus = eventBus;
    this.Events = Events;
  }

  handleDestroy(id) {
    // Remove from minimized manager
    // Remove from tabs map
    // Broadcast close
    // Send to background
    // Emit event
  }

  closeById(id) {
    // Destroy specific tab
  }

  closeAll() {
    // Destroy all tabs
  }
}
```

**Tests:**

- Destroy removes from map
- Destroy removes from minimized
- Broadcast sent
- Background notified
- Event emitted
- CloseAll destroys all tabs

---

### Step 2: Extract Coordinators (2 files, ~250 lines total, ~35 tests)

Create directory: `src/features/quick-tabs/coordinators/`

#### 2.1 UICoordinator

**Responsibilities:**

- Render QuickTabWindow instances from QuickTab entities
- Update UI when state changes
- Handle minimized panel
- Manage QuickTabWindow lifecycle

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/coordinators/UICoordinator.js
export class UICoordinator {
  constructor(stateManager, minimizedManager, panelManager, eventBus) {
    this.stateManager = stateManager;
    this.minimizedManager = minimizedManager;
    this.panelManager = panelManager;
    this.eventBus = eventBus;
    this.renderedTabs = new Map(); // id -> QuickTabWindow
  }

  async renderAll() {
    // Hydrate state, render all visible tabs
  }

  render(quickTab) {
    // Create QuickTabWindow from QuickTab entity
  }

  update(quickTab) {
    // Update existing QuickTabWindow
  }

  destroy(quickTabId) {
    // Remove QuickTabWindow
  }

  setupStateListeners() {
    // Listen to state:added, state:updated, state:deleted
  }
}
```

**Tests:**

- Render creates QuickTabWindow
- Update modifies existing window
- Destroy removes window
- RenderAll hydrates all visible tabs
- State listeners trigger UI updates

---

#### 2.2 SyncCoordinator

**Responsibilities:**

- Coordinate storage ‚Üî state sync
- Handle broadcast messages
- Route messages to appropriate handlers
- Resolve conflicts

**Implementation Pattern:**

```javascript
// src/features/quick-tabs/coordinators/SyncCoordinator.js
export class SyncCoordinator {
  constructor(stateManager, storageManager, broadcastManager, handlers, eventBus) {
    this.stateManager = stateManager;
    this.storageManager = storageManager;
    this.broadcastManager = broadcastManager;
    this.handlers = handlers; // { create, update, visibility, destroy }
    this.eventBus = eventBus;
  }


  setupListeners() {
    // Listen to storage:changed, broadcast:received
  }

  handleStorageChange(newValue) {
    // Sync state from storage
  }

  handleBroadcastMessage({ type, data }) {
    // Route to appropriate handler
    switch (type) {
      case 'CREATE': return this.handlers.create.create(data);
      case 'UPDATE_POSITION': return this.handlers.update.handlePositionChangeEnd(...);
      // etc.
    }
  }
}
```

**Tests:**

- Storage changes sync to state
- Broadcast messages routed correctly
- Conflicts resolved
- Events emitted

---

### Step 3: Refactor QuickTabsManager as Facade (~200 lines)

**Goal:** Reduce QuickTabsManager from 1453 lines ‚Üí ~200 lines

**New Structure:**

```javascript
// src/features/quick-tabs/index.js (refactored)
import { StorageManager } from './managers/StorageManager.js';
import { BroadcastManager } from './managers/BroadcastManager.js';
import { StateManager } from './managers/StateManager.js';
import { EventManager } from './managers/EventManager.js';
import { CreateHandler } from './handlers/CreateHandler.js';
import { UpdateHandler } from './handlers/UpdateHandler.js';
import { VisibilityHandler } from './handlers/VisibilityHandler.js';
import { DestroyHandler } from './handlers/DestroyHandler.js';
import { UICoordinator } from './coordinators/UICoordinator.js';
import { SyncCoordinator } from './coordinators/SyncCoordinator.js';
import { MinimizedManager } from './minimized-manager.js';
import { PanelManager } from './panel.js';
import { CONSTANTS } from '../../core/config.js';
import { EventEmitter } from 'eventemitter3';

class QuickTabsManager {
  constructor() {
    this.tabs = new Map(); // Kept for backward compat
    this.currentZIndex = CONSTANTS.QUICK_TAB_BASE_Z_INDEX;
    this.initialized = false;
    this.cookieStoreId = null;
    this.currentTabId = null;

    // Internal event bus
    this.internalEventBus = new EventEmitter();

    // Initialize managers (deferred - need container context first)
    this.storage = null;
    this.broadcast = null;
    this.state = null;
    this.events = null;

    // Initialize handlers (deferred)
    this.createHandler = null;
    this.updateHandler = null;
    this.visibilityHandler = null;
    this.destroyHandler = null;

    // Initialize coordinators (deferred)
    this.uiCoordinator = null;
    this.syncCoordinator = null;

    // Legacy UI managers
    this.minimizedManager = new MinimizedManager();
    this.panelManager = null;

    // Legacy fields for backward compat
    this.eventBus = null;
    this.Events = null;
  }

  async init(eventBus, Events) {
    if (this.initialized) {
      console.log('[QuickTabsManager] Already initialized, skipping');
      return;
    }

    this.eventBus = eventBus;
    this.Events = Events;

    console.log('[QuickTabsManager] Initializing facade...');

    // 1. Detect container and tab ID
    await this.detectContainerContext();
    await this.detectCurrentTabId();

    // 2. Initialize managers
    this.storage = new StorageManager(this.internalEventBus, this.cookieStoreId);
    this.broadcast = new BroadcastManager(this.internalEventBus, this.cookieStoreId);
    this.state = new StateManager(this.internalEventBus, this.currentTabId);
    this.events = new EventManager(this.internalEventBus, this.tabs);

    // 3. Initialize handlers
    this.createHandler = new CreateHandler(
      this.tabs,
      this.currentZIndex,
      this.cookieStoreId,
      this.broadcast,
      this.eventBus,
      this.Events
    );

    this.updateHandler = new UpdateHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.internalEventBus
    );

    this.visibilityHandler = new VisibilityHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.state,
      this.internalEventBus
    );

    this.destroyHandler = new DestroyHandler(
      this.tabs,
      this.broadcast,
      this.storage,
      this.minimizedManager,
      this.eventBus,
      this.Events
    );

    // 4. Initialize coordinators
    this.uiCoordinator = new UICoordinator(
      this.state,
      this.minimizedManager,
      this.panelManager,
      this.internalEventBus
    );

    this.syncCoordinator = new SyncCoordinator(
      this.state,
      this.storage,
      this.broadcast,
      {
        create: this.createHandler,
        update: this.updateHandler,
        visibility: this.visibilityHandler,
        destroy: this.destroyHandler
      },
      this.internalEventBus
    );

    // 5. Setup managers
    this.storage.setupStorageListeners();
    this.broadcast.setupBroadcastChannel();
    this.events.setupEmergencySaveHandlers();

    // 6. Initialize panel
    this.panelManager = new PanelManager(this);
    await this.panelManager.init();

    // 7. Setup message listeners
    this.setupMessageListeners(); // Keep existing for now

    // 8. Hydrate state
    await this.hydrateStateFromStorage(); // Keep existing for now

    // 9. Setup coordinators
    this.syncCoordinator.setupListeners();
    this.uiCoordinator.setupStateListeners();

    this.initialized = true;
    console.log('[QuickTabsManager] Facade initialized successfully');
  }

  // PUBLIC API - Delegate to handlers/coordinators

  createQuickTab(options) {
    const result = this.createHandler.create(options);
    this.currentZIndex = result.newZIndex;
    return result.tabWindow;
  }

  handleDestroy(id) {
    return this.destroyHandler.handleDestroy(id);
  }

  handleMinimize(id) {
    return this.visibilityHandler.handleMinimize(id);
  }

  handleFocus(id) {
    return this.visibilityHandler.handleFocus(id);
  }

  handlePositionChange(id, left, top) {
    return this.updateHandler.handlePositionChange(id, left, top);
  }

  handlePositionChangeEnd(id, left, top) {
    return this.updateHandler.handlePositionChangeEnd(id, left, top);
  }

  handleSizeChange(id, width, height) {
    return this.updateHandler.handleSizeChange(id, width, height);
  }

  handleSizeChangeEnd(id, width, height) {
    return this.updateHandler.handleSizeChangeEnd(id, width, height);
  }

  handleSoloToggle(quickTabId, newSoloedTabs) {
    return this.visibilityHandler.handleSoloToggle(quickTabId, newSoloedTabs);
  }

  handleMuteToggle(quickTabId, newMutedTabs) {
    return this.visibilityHandler.handleMuteToggle(quickTabId, newMutedTabs);
  }

  closeById(id) {
    return this.destroyHandler.closeById(id);
  }

  closeAll() {
    return this.destroyHandler.closeAll();
  }

  // Keep existing methods that don't fit cleanly into handlers
  // (detectContainerContext, detectCurrentTabId, generateId, etc.)

  async detectContainerContext() {
    // Keep existing implementation
  }

  async detectCurrentTabId() {
    // Keep existing implementation
  }

  generateId() {
    // Keep existing implementation
  }

  // etc.
}

export { QuickTabsManager };
```

---

## üß™ Testing Strategy

### Test Each Component in Isolation

1. **Write tests first** (TDD approach)
2. **Extract component** from QuickTabsManager
3. **Run tests** - verify 100% coverage
4. **Lint code** - ensure cc ‚â§ 9, depth ‚â§ 2
5. **Commit** - separate commit per component

### Integration Testing

After all components extracted:

1. Update `QuickTabsManager` as facade
2. Run existing integration tests (`tests/quick-tabs-creation.test.js`)
3. Add new integration tests for handler coordination
4. Manual testing:
   - Create Quick Tab
   - Resize/drag
   - Solo/mute
   - Minimize/restore
   - Close
   - Cross-tab sync

---

## üìä Success Metrics

### Phase 2.1 Completion Criteria

- [ ] All 10 components extracted (4 managers + 4 handlers + 2 coordinators)
- [ ] QuickTabsManager reduced to <400 lines (facade pattern)
- [ ] All 329+ tests passing
- [ ] Architecture validation passing
- [ ] Bundle sizes within limits (<500KB content.js)
- [ ] Mean CC < 3.5 (currently all managers < 3) ‚úÖ
- [ ] Zero ESLint errors
- [ ] All functionality preserved

### Current Progress vs. Target

| Metric                  | Current    | Target      | Progress |
| ----------------------- | ---------- | ----------- | -------- |
| QuickTabsManager size   | 1453 lines | <400 lines  | 0%       |
| Extracted code          | 850 lines  | ~1100 lines | 77%      |
| New managers/handlers   | 4          | 10          | 40%      |
| Tests                   | 353        | 329+        | 108%     |
| Mean CC (new code)      | <3         | <3.5        | ‚úÖ       |
| Architecture violations | 0          | 0           | ‚úÖ       |

---

## üîß How to Continue

### Recommended Order

1. **CreateHandler** (lines 903-992)
2. **UpdateHandler** (lines 1209-1320)
3. **VisibilityHandler** (lines 1044-1105, 1322-1420)
4. **DestroyHandler** (lines 994-1042, 1163-1207)
5. **UICoordinator** (new logic for QuickTabWindow rendering)
6. **SyncCoordinator** (new logic for message routing)
7. **Facade Integration** (refactor QuickTabsManager to use all components)
8. **Integration Testing** (verify no regressions)

### Commands to Run

```bash
# For each handler:
mkdir -p src/features/quick-tabs/handlers
touch src/features/quick-tabs/handlers/CreateHandler.js
touch tests/unit/handlers/CreateHandler.test.js

# Write tests first
npm run test:unit -- CreateHandler

# Extract logic
# ... implement CreateHandler ...

# Verify
npm run test:unit -- CreateHandler

npm run lint
npm run validate:architecture

# Commit
git add src/features/quick-tabs/handlers/CreateHandler.js tests/unit/handlers/CreateHandler.test.js
git commit -m "feat: Extract CreateHandler from QuickTabsManager"
git push
```

---

## üö® Important Notes for Next Agent

### DO NOT:

- ‚ùå Change existing QuickTabsManager until ALL handlers/coordinators are extracted
- ‚ùå Break backward compatibility
- ‚ùå Remove any existing functionality
- ‚ùå Modify Phase 1 code (domain/storage layers are COMPLETE)
- ‚ùå Change test infrastructure (already perfect)

### DO:

- ‚úÖ Follow the extraction pattern used in EventManager

- ‚úÖ Write tests FIRST before extracting each component
- ‚úÖ Use EventBus/EventEmitter for decoupled communication
- ‚úÖ Maintain 100% test coverage for each extracted component
- ‚úÖ Run tests frequently after each extraction
- ‚úÖ Keep cyclomatic complexity < 3 for all new code
- ‚úÖ Document integration points clearly
- ‚úÖ Commit after each component extraction

### Key Patterns to Follow

**1. Handler Constructor Pattern:**

```javascript
export class XyzHandler {
  constructor(quickTabsMap, ...otherDeps) {
    this.quickTabsMap = quickTabsMap;
    // ... other initialization
  }
}
```

**2. Event Emission Pattern:**

```javascript
this.eventBus?.emit('xyz:action', { data });
```

**3. Async-First Pattern:**

```javascript
async methodName() {
  // All storage/network operations are async
  const result = await this.adapter.load();
  return result;

}
```

**4. Container-Aware Pattern:**

```javascript

constructor(eventBus, cookieStoreId = 'firefox-default') {
  this.cookieStoreId = cookieStoreId;
  // Filter operations by container
}
```

---

## üìù Files Reference

### Created This Session

**Managers:**

- `src/features/quick-tabs/managers/EventManager.js`

**Tests:**

- `tests/unit/managers/EventManager.test.js`

### Created Previous Session

**Managers:**

- `src/features/quick-tabs/managers/StorageManager.js`
- `src/features/quick-tabs/managers/BroadcastManager.js`
- `src/features/quick-tabs/managers/StateManager.js`

**Tests:**

- `tests/unit/managers/StorageManager.test.js`
- `tests/unit/managers/BroadcastManager.test.js`
- `tests/unit/managers/StateManager.test.js`

### Files to Create (Next Session)

**Handlers:**

- `src/features/quick-tabs/handlers/CreateHandler.js`
- `src/features/quick-tabs/handlers/UpdateHandler.js`
- `src/features/quick-tabs/handlers/VisibilityHandler.js`
- `src/features/quick-tabs/handlers/DestroyHandler.js`

**Coordinators:**

- `src/features/quick-tabs/coordinators/UICoordinator.js`
- `src/features/quick-tabs/coordinators/SyncCoordinator.js`

**Tests:** (corresponding test files for each above)

### Files to Modify (Integration Phase)

- `src/features/quick-tabs/index.js` (QuickTabsManager - refactor as facade)

---

## üéØ Estimated Time Remaining

- CreateHandler: 2 hours
- UpdateHandler: 3 hours
- VisibilityHandler: 3 hours
- DestroyHandler: 2 hours
- UICoordinator: 4 hours
- SyncCoordinator: 3 hours
- Facade Integration: 6 hours
- Testing & Validation: 3 hours

**Total: ~26 hours** (3-4 days for experienced developer)

---

## ‚úÖ Quality Gates

Before marking Phase 2.1 complete:

- [ ] All 10 components extracted (4 managers ‚úÖ + 4 handlers + 2 coordinators)
- [ ] QuickTabsManager reduced to <400 lines
- [ ] All 329+ tests passing
- [ ] Zero ESLint errors
- [ ] Architecture validation passing
- [ ] Bundle sizes within limits
- [ ] Mean CC < 3.5
- [ ] All functionality preserved (manual testing)
- [ ] Documentation updated (README, agent files)

---

## üìö Key Documents to Reference

1. **Main Refactoring Plan:** `docs/manual/1.5.9 docs/copy-url-on-hover-refactoring-plan-v2-evidence-based.md`
2. **Infrastructure Plan:** `docs/manual/1.5.9 docs/infrastructure-testing-changes-refactoring.md`
3. **Phase 2.1 Previous Status:** `docs/misc/v1.6.0-REFACTORING-PHASE2.1-STATUS.md`
4. **Phase 1 Complete Summary:** `docs/misc/v1.6.0-REFACTORING-PHASE1-COMPLETE.md`

---

**Good luck with the handler extraction!** The hard architectural work (Phase 1 + Infrastructure) is done. Phase 2.1 is systematic extraction following established patterns. You've got this! üöÄ

---

## üîç Architecture Validation Reference

To verify architecture boundaries are maintained:

```bash
# Check domain/storage independence
npm run validate:architecture

# Check import boundaries
npm run validate:imports

# Check bundle size
npm run build:check-size

# Run all validation
npm run ci:full
```

---

## üß© Integration Points Summary

### Managers ‚Üí Handlers

- **StorageManager** used by: UpdateHandler, VisibilityHandler, DestroyHandler
- **BroadcastManager** used by: CreateHandler, UpdateHandler, VisibilityHandler, DestroyHandler
- **StateManager** used by: VisibilityHandler, UICoordinator, SyncCoordinator
- **EventManager** used by: QuickTabsManager facade (emergency saves)

### Handlers ‚Üí Coordinators

- **CreateHandler** used by: SyncCoordinator (routing broadcast messages)
- **UpdateHandler** used by: SyncCoordinator (routing broadcast messages)
- **VisibilityHandler** used by: SyncCoordinator (routing broadcast messages)
- **DestroyHandler** used by: SyncCoordinator (routing broadcast messages)

### Coordinators ‚Üí Facade

- **UICoordinator** orchestrates: QuickTabWindow rendering, state ‚Üí UI sync
- **SyncCoordinator** orchestrates: Storage ‚Üî state, broadcast ‚Üí handlers

This ensures clean separation of concerns with unidirectional data flow.
