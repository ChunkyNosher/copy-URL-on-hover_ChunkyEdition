# v1.5.8.10 Quick Tabs Restoration Guide

**For:** GitHub Copilot Agent  
**Purpose:** Fix regressions in v1.5.8.10 while maintaining current refactored modular architecture  
**Repository:** ChunkyNosher/copy-URL-on-hover_ChunkyEdition  
**Target Version:** v1.5.8.10 ‚Üí v1.5.9.0+  
**Date:** November 13, 2025

---

## Executive Summary

This document provides comprehensive instructions for restoring Quick Tabs functionality that regressed during the v1.5.8 ‚Üí v1.5.8.10 refactoring. **Critical:** All fixes must maintain the current modular structure in `src/` directory.

### Core Issues to Fix

1. **Issue #35 & #51 Regression**: Quick Tab position/size NOT persisting across tabs
2. **Resize Functionality Broken**: Cannot resize Quick Tabs despite setting enabled
3. **Missing UI Elements**: Lost icon, webpage title, "Open in New Tab" button, pin button
4. **Quick Tab Manager Shortcut**: Move from Firefox shortcuts to extension settings menu
5. **Remove "Persist Across Tabs" Setting**: Always-on behavior, remove toggle
6. **Add Full Settings Page**: Separate HTML page option in Advanced tab

---

## Part 1: Critical Context - What Was Lost in Refactoring

### Pre-Refactor (v1.5.8) Quick Tab Features

The `content-legacy.js` file (183KB monolith) contained these working features:

#### 1. **Complete Quick Tab UI** (Lines 2400-2650 in content-legacy.js)

```javascript
// ‚úì Had: Favicon + Title with webpage icon
const favicon = document.createElement('img');
favicon.style.cssText = `width: 16px; height: 16px; margin-left: 5px;`;
try {
  const urlObj = new URL(url);
  favicon.src = `${GOOGLE_FAVICON_URL}${urlObj.hostname}&sz=32`;
} catch (e) {
  favicon.style.display = 'none';
}

const titleText = document.createElement('span');
titleText.textContent = 'Loading...';
titleText.style.cssText = `flex: 1; font-size: 12px; ...`;

// ‚úì Had: "Open in New Tab" button
const openBtn = document.createElement('button');
openBtn.textContent = 'üîó';
openBtn.title = 'Open in New Tab';
openBtn.onclick = e => {
  e.stopPropagation();
  browser.runtime.sendMessage({
    action: 'openTab',
    url: iframe.src,
    switchFocus: true
  });
};

// ‚úì Had: Pin button with visual feedback
const pinBtn = document.createElement('button');
pinBtn.textContent = pinnedToUrl ? 'üìå' : 'üìç';
pinBtn.title = pinnedToUrl ? `Pinned to: ${pinnedToUrl}` : 'Pin to current page';
```

#### 2. **Working Position/Size Persistence** (Lines 1750-1850)

```javascript
// Three-layer sync architecture:
// 1. BroadcastChannel (same-origin, real-time)
// 2. browser.storage.sync (cross-origin, persisted)
// 3. browser.runtime.sendMessage (background coordination)

async function broadcastQuickTabMove(quickTabId, url, left, top) {
  if (!quickTabChannel || !CONFIG.quickTabPersistAcrossTabs) return;

  quickTabChannel.postMessage({
    action: 'moveQuickTab',
    id: quickTabId,
    url: url,
    left: left,
    top: top,
    cookieStoreId: await getCurrentCookieStoreId(),
    senderId: tabInstanceId,
    timestamp: Date.now()
  });
}
```

#### 3. **Pointer Events-Based Drag/Resize** (Lines 2950-3200)

```javascript
// Used setPointerCapture() to prevent drag slipping
function makeDraggable(element, handle) {
  const handlePointerDown = e => {
    handle.setPointerCapture(e.pointerId); // CRITICAL API
    isDragging = true;
    // ...
  };

  const handlePointerCancel = e => {
    // ISSUE #51 FIX: Save on tab switch
    finalSaveOnDragEnd(currentLeft, currentTop);
  };
}
```

#### 4. **Working Resize Handles** (Lines 3250-3450)

```javascript
function makeResizable(element) {
  const handles = {
    'se': { cursor: 'se-resize', bottom: 0, right: 0 },
    'sw': { cursor: 'sw-resize', bottom: 0, left: 0 },
    'ne': { cursor: 'ne-resize', top: 0, right: 0 },
    'nw': { cursor: 'nw-resize', top: 0, left: 0 },
    'e': { cursor: 'e-resize', ... },
    // ... 8 handles total
  };

  // Each handle had full pointer event capture
}
```

### Current Refactored (v1.5.8.10) Quick Tab Implementation

Located in `src/features/quick-tabs/window.js` (9.4KB):

**What's Missing:**

- ‚ùå No favicon rendering
- ‚ùå No webpage title display
- ‚ùå No "Open in New Tab" button
- ‚ùå No pin button functionality
- ‚ùå Resize handles not working (despite being "created")
- ‚ùå Position/size sync broken across tabs

**What's Present:**

- ‚úì Modular class structure (`QuickTabWindow`)
- ‚úì Basic titlebar with minimize/close buttons
- ‚úì Drag functionality (but not integrated with sync)
- ‚úì Resize handler code (but incomplete/broken)

---

## Part 2: Detailed Fix Instructions

### Fix 1: Restore Full Quick Tab UI in `src/features/quick-tabs/window.js`

**File:** `src/features/quick-tabs/window.js`  
**Location:** `createTitlebar()` method (currently lines 85-145)

#### Step 1.1: Add Favicon Before Title Text

**Insert after line 110 (after `titlebar` creation):**

```javascript
/**
 * Create favicon element
 */
createFavicon() {
  const favicon = createElement('img', {
    className: 'quick-tab-favicon',
    style: {
      width: '16px',
      height: '16px',
      marginLeft: '5px',
      marginRight: '5px',
      flexShrink: '0'
    }
  });

  // Extract domain for favicon
  try {
    const urlObj = new URL(this.url);
    const GOOGLE_FAVICON_URL = 'https://www.google.com/s2/favicons?domain=';
    favicon.src = `${GOOGLE_FAVICON_URL}${urlObj.hostname}&sz=32`;
    favicon.onerror = () => {
      favicon.style.display = 'none';
    };
  } catch (e) {
    favicon.style.display = 'none';
  }

  return favicon;
}
```

**Then modify `createTitlebar()` to include favicon:**

```javascript
// Inside createTitlebar(), after titlebar creation:
const favicon = this.createFavicon();
titlebar.appendChild(favicon); // Add BEFORE titleText
```

#### Step 1.2: Add "Open in New Tab" Button

**Insert after minimize button creation (around line 135):**

```javascript
// Open in New Tab button
const openBtn = this.createButton('üîó', () => {
  // Get current iframe src (might be deferred)
  const currentSrc = this.iframe.src || this.iframe.getAttribute('data-deferred-src');

  // Send message to background script
  browser.runtime.sendMessage({
    action: 'openTab',
    url: currentSrc,
    switchFocus: true // Always switch focus when opening from Quick Tab
  });

  // Optional: Close Quick Tab after opening (check config)
  // if (CONFIG.quickTabCloseOnOpen) {
  //   this.destroy();
  // }
});
openBtn.title = 'Open in New Tab';
controls.appendChild(openBtn);
```

#### Step 1.3: Add Pin Button with Full Functionality

**Insert after "Open in New Tab" button:**

```javascript
// Pin button
const pinBtn = this.createButton(this.pinnedToUrl ? 'üìå' : 'üìç', () => {
  this.togglePin(pinBtn);
});
pinBtn.title = this.pinnedToUrl ? `Pinned to: ${this.pinnedToUrl}` : 'Pin to current page';
pinBtn.style.background = this.pinnedToUrl ? '#444' : 'transparent';
controls.appendChild(pinBtn);

// Store reference for later updates
this.pinButton = pinBtn;
```

**Add new method to QuickTabWindow class:**

```javascript
/**
 * Toggle pin state for Quick Tab
 * @param {HTMLElement} pinBtn - The pin button element
 */
togglePin(pinBtn) {
  if (this.pinnedToUrl) {
    // Unpin
    this.pinnedToUrl = null;
    pinBtn.textContent = 'üìç';
    pinBtn.title = 'Pin to current page';
    pinBtn.style.background = 'transparent';

    // Notify parent (index.js) to broadcast unpin
    if (this.onUnpin) {
      this.onUnpin(this.id);
    }
  } else {
    // Pin to current page URL
    const currentPageUrl = window.location.href;
    this.pinnedToUrl = currentPageUrl;
    pinBtn.textContent = 'üìå';
    pinBtn.title = `Pinned to: ${currentPageUrl}`;
    pinBtn.style.background = '#444';

    // Notify parent (index.js) to broadcast pin and close in other tabs
    if (this.onPin) {
      this.onPin(this.id, currentPageUrl);
    }
  }
}
```

**Update constructor to accept pin/unpin callbacks:**

```javascript
constructor(options) {
  // ... existing code ...
  this.onPin = options.onPin || (() => {});
  this.onUnpin = options.onUnpin || (() => {});
  this.pinnedToUrl = options.pinnedToUrl || null;
}
```

#### Step 1.4: Update Title Text on Load

**Modify the `render()` method to update title when iframe loads:**

```javascript
// Inside render() method, after iframe creation:
this.iframe.addEventListener('load', () => {
  try {
    // Try to get title from iframe (same-origin only)
    const iframeTitle = this.iframe.contentDocument?.title;
    if (iframeTitle) {
      this.title = iframeTitle;
      const titleEl = this.container.querySelector('.quick-tab-title');
      if (titleEl) {
        titleEl.textContent = iframeTitle;
        titleEl.title = iframeTitle;
      }
    } else {
      // Fallback to hostname
      try {
        const urlObj = new URL(this.iframe.src);
        this.title = urlObj.hostname;
        const titleEl = this.container.querySelector('.quick-tab-title');
        if (titleEl) {
          titleEl.textContent = urlObj.hostname;
          titleEl.title = this.iframe.src;
        }
      } catch (e) {
        this.title = 'Quick Tab';
      }
    }
  } catch (e) {
    // Cross-origin - use URL hostname
    try {
      const urlObj = new URL(this.iframe.src);
      this.title = urlObj.hostname;
      const titleEl = this.container.querySelector('.quick-tab-title');
      if (titleEl) {
        titleEl.textContent = urlObj.hostname;
        titleEl.title = this.iframe.src;
      }
    } catch (err) {
      this.title = 'Quick Tab';
    }
  }
});
```

---

### Fix 2: Restore Position/Size Persistence Across Tabs

**Root Cause:** The refactored `window.js` doesn't integrate with the state management system.

**Files to Modify:**

1. `src/features/quick-tabs/window.js` (add callbacks)
2. `src/features/quick-tabs/index.js` (coordinate state sync)

#### Step 2.1: Add State Change Callbacks to QuickTabWindow

**Modify `setupDragHandlers()` in window.js:**

```javascript
setupDragHandlers(titlebar) {
  titlebar.addEventListener('pointerdown', e => {
    if (e.target.tagName === 'BUTTON') return;

    this.isDragging = true;
    this.dragStartX = e.clientX - this.left;
    this.dragStartY = e.clientY - this.top;

    titlebar.setPointerCapture(e.pointerId);
    this.onFocus(this.id);
  });

  titlebar.addEventListener('pointermove', e => {
    if (!this.isDragging) return;

    this.left = e.clientX - this.dragStartX;
    this.top = e.clientY - this.dragStartY;

    this.container.style.left = `${this.left}px`;
    this.container.style.top = `${this.top}px`;

    // **NEW**: Notify parent of position change
    if (this.onPositionChange) {
      this.onPositionChange(this.id, this.left, this.top);
    }
  });

  titlebar.addEventListener('pointerup', e => {
    if (this.isDragging) {
      this.isDragging = false;
      titlebar.releasePointerCapture(e.pointerId);

      // **NEW**: Final save on drag end
      if (this.onPositionChangeEnd) {
        this.onPositionChangeEnd(this.id, this.left, this.top);
      }
    }
  });

  // **CRITICAL FOR ISSUE #51**: Handle tab switch during drag
  titlebar.addEventListener('pointercancel', e => {
    if (this.isDragging) {
      this.isDragging = false;

      // Emergency save position before tab loses focus
      if (this.onPositionChangeEnd) {
        this.onPositionChangeEnd(this.id, this.left, this.top);
      }
    }
  });
}
```

**Update constructor to accept callbacks:**

```javascript
constructor(options) {
  // ... existing code ...
  this.onPositionChange = options.onPositionChange || (() => {});
  this.onPositionChangeEnd = options.onPositionChangeEnd || (() => {});
  this.onSizeChange = options.onSizeChange || (() => {});
  this.onSizeChangeEnd = options.onSizeChangeEnd || (() => {});
}
```

#### Step 2.2: Modify Resize Handlers Similarly

**Update `setupResizeHandlers()` method:**

```javascript
setupResizeHandlers() {
  const resizeHandle = createElement('div', {
    className: 'quick-tab-resize-handle',
    style: {
      position: 'absolute',
      bottom: '0',
      right: '0',
      width: '16px',
      height: '16px',
      cursor: 'se-resize',
      backgroundColor: 'transparent'
    }
  });

  resizeHandle.addEventListener('pointerdown', e => {
    e.stopPropagation();
    this.isResizing = true;
    this.resizeStartWidth = this.width;
    this.resizeStartHeight = this.height;
    this.dragStartX = e.clientX;
    this.dragStartY = e.clientY;

    resizeHandle.setPointerCapture(e.pointerId);
  });

  resizeHandle.addEventListener('pointermove', e => {
    if (!this.isResizing) return;

    const deltaX = e.clientX - this.dragStartX;
    const deltaY = e.clientY - this.dragStartY;

    this.width = Math.max(400, this.resizeStartWidth + deltaX);
    this.height = Math.max(300, this.resizeStartHeight + deltaY);

    this.container.style.width = `${this.width}px`;
    this.container.style.height = `${this.height}px`;

    // **NEW**: Notify parent of size change
    if (this.onSizeChange) {
      this.onSizeChange(this.id, this.width, this.height);
    }
  });

  resizeHandle.addEventListener('pointerup', e => {
    if (this.isResizing) {
      this.isResizing = false;
      resizeHandle.releasePointerCapture(e.pointerId);

      // **NEW**: Final save on resize end
      if (this.onSizeChangeEnd) {
        this.onSizeChangeEnd(this.id, this.width, this.height);
      }
    }
  });

  // **CRITICAL**: Handle interruptions
  resizeHandle.addEventListener('pointercancel', e => {
    if (this.isResizing) {
      this.isResizing = false;

      // Emergency save
      if (this.onSizeChangeEnd) {
        this.onSizeChangeEnd(this.id, this.width, this.height);
      }
    }
  });

  this.container.appendChild(resizeHandle);
}
```

#### Step 2.3: Wire Up State Management in index.js

**File:** `src/features/quick-tabs/index.js`  
**Action:** Add state sync coordinator

**Insert new function:**

```javascript
/**
 * Handle Quick Tab position change (throttled during drag)
 */
let positionChangeThrottle = {};

function handleQuickTabPositionChange(quickTabId, left, top) {
  const now = Date.now();

  // Throttle to 100ms intervals during drag
  if (positionChangeThrottle[quickTabId] && now - positionChangeThrottle[quickTabId] < 100) {
    return;
  }

  positionChangeThrottle[quickTabId] = now;

  // Send to background for cross-tab sync (non-blocking)
  browser.runtime
    .sendMessage({
      action: 'UPDATE_QUICK_TAB_POSITION',
      id: quickTabId,
      left: Math.round(left),
      top: Math.round(top),
      timestamp: now
    })
    .catch(err => {
      console.error('[QuickTabs] Position sync error:', err);
    });
}

/**
 * Handle Quick Tab position change end (final save)
 */
function handleQuickTabPositionChangeEnd(quickTabId, left, top) {
  // Clear throttle
  delete positionChangeThrottle[quickTabId];

  // Send final position to background
  browser.runtime
    .sendMessage({
      action: 'UPDATE_QUICK_TAB_POSITION_FINAL',
      id: quickTabId,
      left: Math.round(left),
      top: Math.round(top),
      timestamp: Date.now()
    })
    .catch(err => {
      console.error('[QuickTabs] Final position save error:', err);
    });
}

/**
 * Handle Quick Tab size change (throttled during resize)
 */
let sizeChangeThrottle = {};

function handleQuickTabSizeChange(quickTabId, width, height) {
  const now = Date.now();

  if (sizeChangeThrottle[quickTabId] && now - sizeChangeThrottle[quickTabId] < 100) {
    return;
  }

  sizeChangeThrottle[quickTabId] = now;

  browser.runtime
    .sendMessage({
      action: 'UPDATE_QUICK_TAB_SIZE',
      id: quickTabId,
      width: Math.round(width),
      height: Math.round(height),
      timestamp: now
    })
    .catch(err => {
      console.error('[QuickTabs] Size sync error:', err);
    });
}

/**
 * Handle Quick Tab size change end (final save)
 */
function handleQuickTabSizeChangeEnd(quickTabId, width, height) {
  delete sizeChangeThrottle[quickTabId];

  browser.runtime
    .sendMessage({
      action: 'UPDATE_QUICK_TAB_SIZE_FINAL',
      id: quickTabId,
      width: Math.round(width),
      height: Math.round(height),
      timestamp: Date.now()
    })
    .catch(err => {
      console.error('[QuickTabs] Final size save error:', err);
    });
}
```

**Modify `createQuickTab()` function to pass callbacks:**

```javascript
export async function createQuickTab(url, options = {}) {
  // ... existing validation code ...

  const window = new QuickTabWindow({
    id: options.id || generateQuickTabId(),
    url: url,
    left: options.left,
    top: options.top,
    width: options.width,
    height: options.height,
    title: options.title,
    cookieStoreId: options.cookieStoreId,
    minimized: false,
    zIndex: options.zIndex || BASE_Z_INDEX + activeQuickTabs.size,
    pinnedToUrl: options.pinnedToUrl || null,

    // **NEW**: State change callbacks
    onPositionChange: handleQuickTabPositionChange,
    onPositionChangeEnd: handleQuickTabPositionChangeEnd,
    onSizeChange: handleQuickTabSizeChange,
    onSizeChangeEnd: handleQuickTabSizeChangeEnd,

    // **NEW**: Pin callbacks
    onPin: handleQuickTabPin,
    onUnpin: handleQuickTabUnpin,

    // Existing callbacks
    onDestroy: id => handleQuickTabDestroy(id),
    onMinimize: id => handleQuickTabMinimize(id),
    onFocus: id => bringToFront(id)
  });

  window.render();
  activeQuickTabs.set(window.id, window);

  // Save to storage
  await saveQuickTabState();

  return window;
}
```

**Add pin handler functions:**

```javascript
/**
 * Handle Quick Tab pin
 */
function handleQuickTabPin(quickTabId, pinnedToUrl) {
  browser.runtime
    .sendMessage({
      action: 'PIN_QUICK_TAB',
      id: quickTabId,
      pinnedToUrl: pinnedToUrl,
      timestamp: Date.now()
    })
    .then(() => {
      // Close this Quick Tab in all other tabs
      // Background script will handle broadcasting
    })
    .catch(err => {
      console.error('[QuickTabs] Pin sync error:', err);
    });
}

/**
 * Handle Quick Tab unpin
 */
function handleQuickTabUnpin(quickTabId) {
  browser.runtime
    .sendMessage({
      action: 'UNPIN_QUICK_TAB',
      id: quickTabId,
      timestamp: Date.now()
    })
    .then(() => {
      // Restore this Quick Tab in all tabs
      // Background script will handle broadcasting
    })
    .catch(err => {
      console.error('[QuickTabs] Unpin sync error:', err);
    });
}
```

---

### Fix 3: Restore Resize Functionality

**Problem:** The current `setupResizeHandlers()` only creates ONE handle (SE corner). Need 8 handles like v1.5.8.

#### Step 3.1: Replace setupResizeHandlers() Method

**File:** `src/features/quick-tabs/window.js`  
**Replace existing `setupResizeHandlers()` entirely:**

```javascript
/**
 * Setup resize handlers on all 8 edges/corners
 * Uses Pointer Events API for reliable capture
 */
setupResizeHandlers() {
  const minWidth = 400;
  const minHeight = 300;
  const handleSize = 10;

  // Define all 8 resize handles
  const handles = {
    'se': { cursor: 'se-resize', bottom: 0, right: 0, width: handleSize, height: handleSize },
    'sw': { cursor: 'sw-resize', bottom: 0, left: 0, width: handleSize, height: handleSize },
    'ne': { cursor: 'ne-resize', top: 0, right: 0, width: handleSize, height: handleSize },
    'nw': { cursor: 'nw-resize', top: 0, left: 0, width: handleSize, height: handleSize },
    'e': { cursor: 'e-resize', top: handleSize, right: 0, bottom: handleSize, width: handleSize },
    'w': { cursor: 'w-resize', top: handleSize, left: 0, bottom: handleSize, width: handleSize },
    's': { cursor: 's-resize', bottom: 0, left: handleSize, right: handleSize, height: handleSize },
    'n': { cursor: 'n-resize', top: 0, left: handleSize, right: handleSize, height: handleSize }
  };

  Object.entries(handles).forEach(([direction, config]) => {
    const handle = createElement('div', {
      className: `quick-tab-resize-handle-${direction}`,
      style: {
        position: 'absolute',
        ...(config.top !== undefined ? { top: `${config.top}px` } : {}),
        ...(config.bottom !== undefined ? { bottom: `${config.bottom}px` } : {}),
        ...(config.left !== undefined ? { left: `${config.left}px` } : {}),
        ...(config.right !== undefined ? { right: `${config.right}px` } : {}),
        ...(config.width ? { width: `${config.width}px` } : {}),
        ...(config.height ? { height: `${config.height}px` } : {}),
        cursor: config.cursor,
        zIndex: '10',
        backgroundColor: 'transparent' // Invisible but interactive
      }
    });

    let isResizing = false;
    let startX, startY, startWidth, startHeight, startLeft, startTop;

    handle.addEventListener('pointerdown', e => {
      if (e.button !== 0) return;

      e.stopPropagation();
      e.preventDefault();

      isResizing = true;
      handle.setPointerCapture(e.pointerId);

      startX = e.clientX;
      startY = e.clientY;
      startWidth = this.width;
      startHeight = this.height;
      startLeft = this.left;
      startTop = this.top;
    });

    handle.addEventListener('pointermove', e => {
      if (!isResizing) return;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;

      // Calculate new dimensions based on resize direction
      if (direction.includes('e')) {
        newWidth = Math.max(minWidth, startWidth + dx);
      }
      if (direction.includes('w')) {
        const maxDx = startWidth - minWidth;
        const constrainedDx = Math.min(dx, maxDx);
        newWidth = startWidth - constrainedDx;
        newLeft = startLeft + constrainedDx;
      }
      if (direction.includes('s')) {
        newHeight = Math.max(minHeight, startHeight + dy);
      }
      if (direction.includes('n')) {
        const maxDy = startHeight - minHeight;
        const constrainedDy = Math.min(dy, maxDy);
        newHeight = startHeight - constrainedDy;
        newTop = startTop + constrainedDy;
      }

      // Apply immediately (no RAF delay)
      this.width = newWidth;
      this.height = newHeight;
      this.left = newLeft;
      this.top = newTop;

      this.container.style.width = `${newWidth}px`;
      this.container.style.height = `${newHeight}px`;
      this.container.style.left = `${newLeft}px`;
      this.container.style.top = `${newTop}px`;

      // Notify parent (throttled)
      if (this.onSizeChange) {
        this.onSizeChange(this.id, newWidth, newHeight);
      }
      if (newLeft !== startLeft || newTop !== startTop) {
        if (this.onPositionChange) {
          this.onPositionChange(this.id, newLeft, newTop);
        }
      }

      e.preventDefault();
    });

    handle.addEventListener('pointerup', e => {
      if (!isResizing) return;

      isResizing = false;
      handle.releasePointerCapture(e.pointerId);

      // Final save
      if (this.onSizeChangeEnd) {
        this.onSizeChangeEnd(this.id, this.width, this.height);
      }
      if (this.left !== startLeft || this.top !== startTop) {
        if (this.onPositionChangeEnd) {
          this.onPositionChangeEnd(this.id, this.left, this.top);
        }
      }
    });

    handle.addEventListener('pointercancel', e => {
      if (isResizing) {
        isResizing = false;

        // Emergency save
        if (this.onSizeChangeEnd) {
          this.onSizeChangeEnd(this.id, this.width, this.height);
        }
        if (this.onPositionChangeEnd) {
          this.onPositionChangeEnd(this.id, this.left, this.top);
        }
      }
    });

    this.container.appendChild(handle);
  });
}
```

---

### Fix 4: Quick Tab Manager Shortcut Configuration

**Current State:** Shortcut (`Ctrl+Alt+Z`) is hardcoded in `manifest.json`  
**Desired State:** Configurable via extension settings menu

#### Step 4.1: Remove Hardcoded Shortcut from Manifest

**File:** `manifest.json`  
**Action:** Remove the `commands` section (or make it dynamic)

```json
// REMOVE THIS SECTION:
"commands": {
  "toggle-quick-tabs-manager": {
    "suggested_key": {
      "default": "Ctrl+Alt+Z"
    },
    "description": "Toggle Quick Tabs Manager panel"
  }
}
```

#### Step 4.2: Add Shortcut Configuration to Settings

**File:** `popup.html`  
**Location:** Inside the "Advanced" tab section

**Insert after existing Advanced settings (around line 200):**

```html
<!-- Quick Tab Manager Shortcut -->
<div class="setting-row">
  <label class="setting-label">
    Quick Tab Manager Shortcut
    <span class="setting-hint">Keyboard shortcut to toggle Quick Tab Manager panel</span>
  </label>
  <div class="shortcut-config">
    <input
      type="text"
      id="quickTabManagerShortcut"
      class="setting-input"
      placeholder="Ctrl+Alt+Z"
      readonly
      style="width: 150px;"
    />
    <button id="recordShortcutBtn" class="setting-button">Record</button>
    <button id="clearShortcutBtn" class="setting-button">Clear</button>
  </div>
</div>
```

**Add CSS for shortcut recorder:**

```css
.shortcut-config {
  display: flex;
  gap: 8px;
  align-items: center;
}

.shortcut-config input {
  font-family: monospace;
  text-align: center;
}

.shortcut-config input.recording {
  border-color: #4caf50;
  background-color: #e8f5e9;
}
```

#### Step 4.3: Implement Shortcut Recorder in popup.js

**File:** `popup.js`  
**Insert at end of file:**

```javascript
// Quick Tab Manager Shortcut Configuration
let isRecordingShortcut = false;
let recordedKeys = new Set();

document.getElementById('recordShortcutBtn').addEventListener('click', () => {
  const input = document.getElementById('quickTabManagerShortcut');
  const recordBtn = document.getElementById('recordShortcutBtn');

  if (!isRecordingShortcut) {
    // Start recording
    isRecordingShortcut = true;
    recordedKeys.clear();
    input.classList.add('recording');
    input.value = 'Press keys...';
    recordBtn.textContent = 'Stop';

    // Listen for keydown
    document.addEventListener('keydown', handleShortcutRecord);
  } else {
    // Stop recording
    stopShortcutRecording();
  }
});

document.getElementById('clearShortcutBtn').addEventListener('click', () => {
  document.getElementById('quickTabManagerShortcut').value = '';
  browser.storage.local.set({ quickTabManagerShortcut: null });
});

function handleShortcutRecord(e) {
  if (!isRecordingShortcut) return;

  e.preventDefault();
  e.stopPropagation();

  // Build shortcut string
  const parts = [];
  if (e.ctrlKey || e.metaKey) parts.push('Ctrl');
  if (e.altKey) parts.push('Alt');
  if (e.shiftKey) parts.push('Shift');

  // Add key (ignore modifiers)
  if (!['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {
    parts.push(e.key.toUpperCase());

    // Valid shortcut recorded
    const shortcut = parts.join('+');
    document.getElementById('quickTabManagerShortcut').value = shortcut;

    // Save to storage
    browser.storage.local.set({ quickTabManagerShortcut: shortcut });

    // Stop recording
    stopShortcutRecording();
  } else {
    // Just modifiers - show partial
    document.getElementById('quickTabManagerShortcut').value = parts.join('+') + '+';
  }
}

function stopShortcutRecording() {
  isRecordingShortcut = false;
  recordedKeys.clear();
  document.getElementById('quickTabManagerShortcut').classList.remove('recording');
  document.getElementById('recordShortcutBtn').textContent = 'Record';
  document.removeEventListener('keydown', handleShortcutRecord);
}

// Load saved shortcut on popup open
browser.storage.local.get('quickTabManagerShortcut').then(result => {
  if (result.quickTabManagerShortcut) {
    document.getElementById('quickTabManagerShortcut').value = result.quickTabManagerShortcut;
  } else {
    document.getElementById('quickTabManagerShortcut').value = 'Ctrl+Alt+Z'; // Default
  }
});
```

#### Step 4.4: Implement Shortcut Listener in Content Script

**File:** `src/content.js`  
**Add global keyboard listener:**

```javascript
// Load Quick Tab Manager shortcut
let quickTabManagerShortcut = 'Ctrl+Alt+Z'; // Default

browser.storage.local.get('quickTabManagerShortcut').then(result => {
  if (result.quickTabManagerShortcut) {
    quickTabManagerShortcut = result.quickTabManagerShortcut;
  }
});

// Listen for storage changes
browser.storage.onChanged.addListener((changes, area) => {
  if (area === 'local' && changes.quickTabManagerShortcut) {
    quickTabManagerShortcut = changes.quickTabManagerShortcut.newValue || 'Ctrl+Alt+Z';
  }
});

// Global keyboard listener for Quick Tab Manager
document.addEventListener(
  'keydown',
  e => {
    // Parse current shortcut
    const parts = quickTabManagerShortcut.split('+');
    const requiresCtrl = parts.includes('Ctrl');
    const requiresAlt = parts.includes('Alt');
    const requiresShift = parts.includes('Shift');
    const key = parts[parts.length - 1]; // Last part is the key

    // Check if current press matches
    const ctrlMatch = (e.ctrlKey || e.metaKey) === requiresCtrl;
    const altMatch = e.altKey === requiresAlt;
    const shiftMatch = e.shiftKey === requiresShift;
    const keyMatch = e.key.toUpperCase() === key;

    if (ctrlMatch && altMatch && shiftMatch && keyMatch) {
      e.preventDefault();
      e.stopPropagation();

      // Toggle Quick Tab Manager
      browser.runtime.sendMessage({
        action: 'TOGGLE_QUICK_TABS_PANEL'
      });
    }
  },
  true
);
```

---

### Fix 5: Remove "Persist Quick Tabs Across Tabs" Setting

**Rationale:** Quick Tabs should ALWAYS persist across tabs. The toggle is confusing and breaks expectations.

#### Step 5.1: Remove Setting from UI

**File:** `popup.html`  
**Action:** Find and DELETE this entire setting block (search for "quickTabPersistAcrossTabs")

```html
<!-- DELETE THIS ENTIRE BLOCK -->
<div class="setting-row">
  <label class="setting-label">
    <input type="checkbox" id="quickTabPersistAcrossTabs" class="setting-checkbox" />
    Persist Quick Tabs across browser tabs
    <span class="setting-hint">Quick Tabs remain visible when switching tabs</span>
  </label>
</div>
```

#### Step 5.2: Remove from Default Config

**File:** `src/core/config.js`  
**Action:** Remove `quickTabPersistAcrossTabs` from DEFAULT_CONFIG

```javascript
export const DEFAULT_CONFIG = {
  // ... other settings ...

  // Quick Tab settings
  quickTabKey: 'q',
  quickTabCtrl: false,
  quickTabAlt: false,
  quickTabShift: false,
  quickTabMaxWindows: 3,
  quickTabDefaultWidth: 800,
  quickTabDefaultHeight: 600,
  quickTabEnableResize: true
  // quickTabPersistAcrossTabs: true, // ‚ùå REMOVE THIS LINE

  // ... other settings ...
};
```

#### Step 5.3: Remove Conditional Checks

**Files:** All files in `src/features/quick-tabs/`  
**Action:** Search for `CONFIG.quickTabPersistAcrossTabs` and remove conditional checks

**Example in index.js:**

```javascript
// BEFORE (conditional):
if (CONFIG.quickTabPersistAcrossTabs) {
  await saveQuickTabState();
}

// AFTER (always save):
await saveQuickTabState();
```

**Do this for ALL occurrences in:**

- `src/features/quick-tabs/index.js`
- `src/features/quick-tabs/window.js`
- `src/features/quick-tabs/minimized-manager.js`

---

### Fix 6: Add Full Settings Page Option

**Requirement:** Add option in Advanced tab to open settings in a separate HTML page that syncs with popup.

#### Step 6.1: Create Settings Page HTML

**Create new file:** `options_page_fullscreen.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Copy URL on Hover - Settings</title>
    <link rel="stylesheet" href="popup.html" />
    <!-- Reuse styles -->
    <style>
      body {
        width: 100%;
        max-width: 900px;
        margin: 40px auto;
        padding: 20px;
      }

      .page-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 2px solid #444;
      }

      .page-title {
        font-size: 28px;
        font-weight: 600;
        color: #e0e0e0;
      }

      .close-page-btn {
        padding: 8px 16px;
        background: #444;
        color: #e0e0e0;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .close-page-btn:hover {
        background: #555;
      }
    </style>
  </head>
  <body>
    <div class="page-header">
      <h1 class="page-title">üîó Copy URL on Hover - Settings</h1>
      <button id="closePageBtn" class="close-page-btn">Close</button>
    </div>

    <!-- Embed entire popup.html content here (without <html><body> tags) -->
    <!-- OR use iframe: -->
    <iframe src="popup.html" style="width: 100%; height: 800px; border: none;"></iframe>

    <script src="options_page_fullscreen.js"></script>
  </body>
</html>
```

#### Step 6.2: Create Settings Page Script

**Create new file:** `options_page_fullscreen.js`

```javascript
// Close button handler
document.getElementById('closePageBtn').addEventListener('click', () => {
  window.close();
});

// If using iframe approach, no additional logic needed
// Settings will auto-sync via browser.storage listeners

// If embedding content directly, copy all popup.js logic here
```

#### Step 6.3: Add "Open Full Settings" Button

**File:** `popup.html`  
**Location:** In the "Advanced" tab

**Insert at the top of Advanced tab content:**

```html
<div class="setting-row" style="margin-bottom: 20px;">
  <button id="openFullSettingsBtn" class="setting-button" style="width: 100%; padding: 12px;">
    üìÑ Open Full Settings Page
  </button>
</div>
```

**Add handler in popup.js:**

```javascript
document.getElementById('openFullSettingsBtn').addEventListener('click', () => {
  browser.tabs.create({
    url: browser.runtime.getURL('options_page_fullscreen.html')
  });
});
```

#### Step 6.4: Update manifest.json

**File:** `manifest.json`  
**Add to `web_accessible_resources`:**

```json
"web_accessible_resources": [
  "state-manager.js",
  "options_page_fullscreen.html"
]
```

---

## Part 3: Testing Checklist

After implementing all fixes, test the following scenarios:

### Test 1: UI Restoration

- [ ] Quick Tab shows favicon of website
- [ ] Quick Tab shows webpage title (or hostname if cross-origin)
- [ ] "Open in New Tab" button (üîó) visible and functional
- [ ] Pin button (üìç/üìå) visible and functional
- [ ] Minimize button (‚àí) works
- [ ] Close button (‚úï) works

### Test 2: Resize Functionality

- [ ] Can resize from SE corner
- [ ] Can resize from SW corner
- [ ] Can resize from NE corner
- [ ] Can resize from NW corner
- [ ] Can resize from E edge
- [ ] Can resize from W edge
- [ ] Can resize from S edge
- [ ] Can resize from N edge
- [ ] Minimum size enforced (400x300)

### Test 3: Position/Size Persistence (Issue #51)

- [ ] Open Quick Tab in Tab 1, move to bottom-right
- [ ] Switch to Tab 2 ‚Üí Quick Tab appears in bottom-right
- [ ] Resize Quick Tab in Tab 2
- [ ] Switch to Tab 3 ‚Üí Quick Tab has new size from Tab 2
- [ ] Move Quick Tab in Tab 3
- [ ] Switch back to Tab 1 ‚Üí Quick Tab has new position from Tab 3

### Test 4: Pin Functionality

- [ ] Pin Quick Tab to Tab 1
- [ ] Switch to Tab 2 ‚Üí Quick Tab NOT visible
- [ ] Switch back to Tab 1 ‚Üí Quick Tab still visible
- [ ] Unpin Quick Tab in Tab 1
- [ ] Switch to Tab 2 ‚Üí Quick Tab NOW visible

### Test 5: Quick Tab Manager Shortcut

- [ ] Open settings, go to Advanced tab
- [ ] Click "Record" button
- [ ] Press `Ctrl+Shift+Q`
- [ ] Shortcut saved and displayed
- [ ] Press `Ctrl+Shift+Q` on any page ‚Üí Quick Tab Manager opens
- [ ] Press again ‚Üí Manager closes

### Test 6: Full Settings Page

- [ ] Click "Open Full Settings Page" in Advanced tab
- [ ] New tab opens with full settings
- [ ] Change a setting in full page ‚Üí Popup reflects change
- [ ] Change a setting in popup ‚Üí Full page reflects change
- [ ] Close full page ‚Üí Settings persisted

---

## Part 4: Migration Notes for Copilot

### Architecture Constraints

**DO NOT:**

- ‚ùå Merge files back into monolithic structure
- ‚ùå Remove modular `src/` directory structure
- ‚ùå Break ES6 module imports/exports
- ‚ùå Remove existing abstraction layers

**DO:**

- ‚úÖ Maintain separation: `features/`, `ui/`, `core/`, `utils/`
- ‚úÖ Use existing helper functions in `utils/dom.js`
- ‚úÖ Follow existing event-driven patterns
- ‚úÖ Keep state management centralized
- ‚úÖ Add new functions, don't replace entire files

### Key APIs to Preserve

1. **Pointer Events API** (`setPointerCapture`) - Critical for drag/resize
2. **Browser Storage API** (`browser.storage.sync`) - Cross-tab persistence
3. **Runtime Messaging** (`browser.runtime.sendMessage`) - Background coordination
4. **Contextual Identities API** (`browser.contextualIdentities`) - Container support

### Files NOT to Modify

- `manifest.json` (except for removing hardcoded shortcut)
- `rollup.config.js`
- `.eslintrc.cjs`
- `package.json`

### Files to Create

- `options_page_fullscreen.html`
- `options_page_fullscreen.js`

### Files to Heavily Modify

- `src/features/quick-tabs/window.js` (UI restoration, resize handles)
- `src/features/quick-tabs/index.js` (state sync coordination)
- `popup.html` (shortcut recorder UI, full settings button)
- `popup.js` (shortcut configuration logic)
- `src/content.js` (shortcut listener)

---

## Part 5: Expected Outcomes

After all fixes are implemented:

### User Experience

1. **Quick Tabs look professional** with favicons, titles, and complete controls
2. **Resize from any edge/corner** with 8 functional handles
3. **Position and size persist** flawlessly across all tabs (fixes #35 and #51)
4. **Pin to specific tabs** for privacy/organization
5. **Customize keyboard shortcuts** without touching Firefox settings
6. **Open settings in full page** for easier configuration
7. **Simplified UX** - no confusing "persist across tabs" toggle

### Code Quality

1. **Maintained modular structure** - no regression to monolith
2. **Proper separation of concerns** - UI, state, coordination
3. **Robust error handling** - graceful degradation
4. **Performance optimized** - throttled sync, efficient listeners
5. **Well-documented** - inline comments explaining complex logic

### Bug Resolutions

- ‚úÖ **Issue #35 RESOLVED**: Quick Tabs now persist across tabs
- ‚úÖ **Issue #51 RESOLVED**: Position/size updates transfer between tabs
- ‚úÖ **Resize Bug RESOLVED**: All 8 handles working correctly
- ‚úÖ **UI Regression RESOLVED**: Full v1.5.8 feature parity

---

## Part 6: References

### Source Files to Study

1. **v1.5.8 Legacy Implementation**
   - `content-legacy.js` (lines 2000-3500) - Complete Quick Tab system
2. **Current Refactored Structure**
   - `src/features/quick-tabs/window.js` - Current incomplete implementation
   - `src/features/quick-tabs/index.js` - Orchestration layer
   - `src/features/quick-tabs/minimized-manager.js` - Minimize logic

3. **Related Issues**
   - Issue #35: "Quick Tabs don't persist across tabs"
   - Issue #51: "Size and Position Unable to Update"
   - Issue #47: "All intended behaviors" (comprehensive spec)

### External Documentation

- [Pointer Events API - MDN](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events)
- [Firefox Extensions - browser.storage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage)
- [Firefox Extensions - browser.runtime.sendMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage)

---

## Conclusion

This guide provides GitHub Copilot Agent with everything needed to restore Quick Tabs to full v1.5.8 functionality while preserving the modern refactored architecture. All fixes are surgical - targeting specific methods and adding new functions without breaking existing patterns.

**Priority Order:**

1. Fix UI (Part 2, Fix 1) - Visual regression
2. Fix resize (Part 2, Fix 3) - Core functionality
3. Fix persistence (Part 2, Fix 2) - Critical bugs #35 & #51
4. Add shortcut config (Part 2, Fix 4) - UX improvement
5. Remove persist toggle (Part 2, Fix 5) - UX simplification
6. Add full settings (Part 2, Fix 6) - Nice-to-have

Good luck, Copilot! üöÄ
