# Quick Tabs & Manager: Multiple Persistence, Sync, and Logging Issues

**Extension Version:** v1.6.3.5  
**Date:** 2025-12-03  

**Scope:** Multiple persistence failures, state synchronization bugs, cross-tab restore issues, and missing diagnostic logging across Quick Tabs feature and Manager sidebar

---

## Executive Summary

Quick Tabs v1.6.3.5 exhibits multiple critical and high-severity issues affecting state persistence, cross-tab synchronization, and user experience. The Manager sidebar frequently displays stale or empty tab lists, restore operations sometimes create duplicate windows or appear on incorrect browser tabs, and minimize operations occasionally lose state. Additionally, diagnostic logging is incomplete, making it difficult to debug issues in production environments.

These issues stem from five distinct root causes across different handlers, coordinators, and UI components. While each has a separate technical cause, all affect the reliability of Quick Tab state management and the Manager's ability to accurately reflect current state. Issues were identified through comprehensive log analysis, code review, and architectural inspection of the v1.6.3.5 codebase.

## Issues Overview

| # | Issue | Component | Severity | Root Cause |
|---|-------|-----------|----------|------------|
| 1 | Manager shows empty list after minimize/restore | Manager + MinimizedManager | Critical | Missing storage write after snapshot clear |
| 2 | Restore creates duplicate windows | VisibilityHandler + UICoordinator | Critical | Race condition: both call `render()` |
| 3 | Cross-tab restore appears on wrong side | Manager broadcast pattern | High | Global `_sendMessageToAllTabs` |
| 4 | Position/size not persisted during drag/resize | UpdateHandler | High | Intermediate updates bypass storage |
| 5 | Missing logging for state transitions | StateManager + handlers | High | No logs for storage reads/writes |
| 6 | Minimize state lost on reload | VisibilityHandler | Medium | `domVerified` not persisted |
| 7 | Manager "Last sync" timestamp incorrect | Manager UI | Medium | Uses storage timestamp, not actual sync time |
| 8 | Z-index desync causes focus anomalies | FocusManager | Medium | Z-index updates bypass storage |

**Why bundled:** All affect Quick Tab state visibility and reliability, share storage/sync architecture, and can be fixed in a coordinated effort. Fixing these together ensures consistent behavior across the entire state management pipeline.

<scope>
**Modify:**
- `src/features/quick-tabs/managers/MinimizedManager.js` (clearSnapshot method)
- `src/features/quick-tabs/handlers/VisibilityHandler.js` (handleRestore method)
- `src/features/quick-tabs/coordinators/UICoordinator.js` (update method, render logic)
- `src/features/quick-tabs/handlers/UpdateHandler.js` (handlePositionChange, handleSizeChange)
- `src/features/quick-tabs/managers/StateManager.js` (save method, load method)
- `src/features/quick-tabs/managers/FocusManager.js` (bringToFront method)
- `sidebar/quick-tabs-manager.js` (loadQuickTabsState, updateUIStats, renderUI)

**Do NOT Modify:**
- `background.js` (out of scope for this diagnostic)
- `src/features/quick-tabs/mediator.js` (state machine transitions work correctly)
- `manifest.json` (no permissions changes needed)
</scope>

---

## Issue 1: Manager Shows Empty List After Minimize/Restore

### Problem
After minimizing a Quick Tab, the Manager sidebar often shows an empty tab list instead of displaying the minimized tab with a yellow indicator. Occasionally, restoring a minimized tab also results in the Manager showing zero tabs until a manual reload.

### Root Cause

**File:** `src/features/quick-tabs/managers/MinimizedManager.js`  
**Location:** `clearSnapshot()` method (lines 89-104)  
**Issue:** When a snapshot is cleared after restore, the method removes the entry from the internal `snapshots` Map but does not trigger a storage write to persist the removal. The Manager's `storage.onChanged` listener never fires, so the UI continues showing stale minimized state.

The `clearSnapshot` method logs the removal but does not call `StateManager.save()` or directly write to storage, creating a desync between MinimizedManager's in-memory state and what the Manager reads from storage.

### Fix Required

Add storage persistence after clearing snapshot. Follow the pattern used in `VisibilityHandler.handleMinimize` where state changes are immediately persisted. Ensure the storage write includes the updated list of minimized tabs (or an empty array if all were restored) so the Manager's listener receives the change.

---

## Issue 2: Restore Creates Duplicate Windows

### Problem
Restoring a minimized Quick Tab sometimes creates two overlapping windows at the same position. One window is interactive, the other is a non-interactive "ghost" that remains until manually destroyed. This occurs approximately 15-20% of restore attempts, particularly when rapidly clicking restore.

### Root Cause

**Files:**
- `src/features/quick-tabs/handlers/VisibilityHandler.js` (handleRestore method, lines 112-148)
- `src/features/quick-tabs/coordinators/UICoordinator.js` (update method, lines 87-123)

**Issue:** Race condition where both `VisibilityHandler.handleRestore` and `UICoordinator.update` independently call `quickTabWindow.render()` on the same Quick Tab instance during the same restore operation.

The sequence is:
1. `VisibilityHandler.handleRestore` is called by mediator
2. It sets `quickTab.minimized = false` and immediately calls `quickTab.render()`
3. It then notifies `UICoordinator.update()` with the state change
4. `UICoordinator.update` sees `!minimized && !isRendered()` and calls `quickTab.render()` again
5. Two separate DOM container elements are created with the same `id` (violating unique ID constraint)

The duplicate render call happens because `quickTab.rendered` flag is not updated synchronously—`render()` sets it asynchronously via `requestAnimationFrame`, so the check in `UICoordinator.update` still sees `rendered: false`.

### Fix Required

Ensure only one authority calls `render()` during restore operations. Options include:
- Have `VisibilityHandler` NOT call `render()` and defer entirely to `UICoordinator.update()`
- OR have `UICoordinator.update()` check if render is already in-progress (add a `rendering` transient flag)
- OR make `render()` idempotent by checking `this.container?.parentNode` before creating new DOM

Follow the single-responsibility principle: one component owns DOM creation, others only update state and notify.

---

## Issue 3: Cross-Tab Restore Appears on Wrong Side of Split View

### Problem
In Zen Browser split view (or Firefox with multiple visible tabs), restoring a minimized Quick Tab from the Manager sometimes causes the window to appear on the "wrong" browser tab/pane—not the one where the Quick Tab was originally created. User expects restored window to appear in the same browser tab where it was minimized.

### Root Cause

**File:** `sidebar/quick-tabs-manager.js`  
**Location:** `restoreQuickTab()` method (lines 1165-1223), specifically `_sendMessageToAllTabs` (lines 1080-1099)

**Issue:** The Manager sends `RESTORE_QUICK_TAB` messages to **all browser tabs** via `browser.tabs.query({})` loop, with no targeting of the specific tab that owns the Quick Tab. Any content script that has a Quick Tab with matching ID will respond, even if it's in a different browser tab.

The Manager has tracking data (`quickTabHostInfo` Map with `hostTabId`) but does not use it when sending restore commands. Instead, it broadcasts globally, which works in single-window scenarios but fails in split-view or multi-tab environments where the same Quick Tab ID pattern might exist or stale instances remain.

### Fix Required

Use the Manager's `quickTabHostInfo` Map (lines 62-63) or the `originTabId` stored in Quick Tab state to target restore messages to the specific browser tab that hosts the Quick Tab. Send `browser.tabs.sendMessage(hostTabId, ...)` to a single tab instead of broadcasting to all tabs.

If `hostTabId` is not available (missing from cache), query storage for the Quick Tab's `originTabId` and use that. Add logging to warn when host tab cannot be determined.

---

## Issue 4: Position/Size Not Persisted During Drag/Resize

### Problem
When dragging or resizing a Quick Tab window, the intermediate position and size changes are not persisted to storage until the operation fully completes (drag end / resize end). If the browser crashes or extension reloads during a drag/resize, the Quick Tab reverts to its old position/size on restore, losing user's intended changes.

Additionally, the Manager does not show live position/size updates during drag/resize—it only updates after the operation completes.

### Root Cause

**File:** `src/features/quick-tabs/handlers/UpdateHandler.js`  
**Location:** `handlePositionChange()` (lines 52-71) and `handleSizeChange()` (lines 95-114)

**Issue:** The handler differentiates between intermediate updates (`handlePositionChange`, `handleSizeChange`) and final updates (`handlePositionChangeEnd`, `handleSizeChangeEnd`). Only the "End" methods call `StateManager.save()`. Intermediate updates only modify the in-memory `quickTab` object without persisting.

This design prevents storage write storms during rapid drag/resize but creates a window where state can be lost. If a crash occurs during drag, there is no persisted record of the partial movement.

Additionally, intermediate updates do not trigger any event that the Manager listens for, so the Manager's position/size display remains frozen until drag/resize completes.

### Fix Required

Add debounced storage persistence during intermediate updates. Introduce a debounce timer (100-200ms) that writes to storage if no further updates arrive within the window. This balances write frequency with state safety.

Alternatively, add a "dirty flag" that triggers a background auto-save every N seconds if any Quick Tab has unsaved position/size changes.

For Manager live updates, emit a lightweight message or event on intermediate changes that the Manager can listen for to update its display without triggering full storage writes.

---

## Issue 5: Missing Logging for State Transitions

### Problem
Diagnostic logs do not capture critical state transition events, making it difficult to debug issues like:
- When a Quick Tab is added/removed from storage
- Which component triggered a storage write and why
- What the full state looked like before/after a write
- Whether `storage.onChanged` fired in response to a write

Users experiencing issues cannot provide actionable logs, and developers cannot reproduce bugs from log exports.

### Root Cause

**File:** `src/features/quick-tabs/managers/StateManager.js`  
**Location:** `save()` method (lines 48-89) and `load()` method (lines 108-152)

**Issue:** The `save()` method logs the number of tabs and a `saveId`, but does not log:
- The actual tab data being saved (URLs, positions, minimized state, etc.)
- Which operation triggered the save (minimize, restore, create, destroy, etc.)
- Storage read/write latency or success/failure details

The `load()` method logs "Loaded state" with a tab count, but does not log:
- What the loaded state contains (full tab list)
- Whether the load was from `storage.local` vs. `storage.sync` (fallback path)
- Any validation failures or data corruption detected during load

Additionally, `storage.onChanged` listeners in background and Manager do not consistently log when they receive changes or why they're processing them.

### Fix Required

Add comprehensive logging to `StateManager.save()` and `load()`:
- Before save: log operation source (e.g., "minimize", "restore", "position-update") and full state snapshot (abbreviated URLs)
- After save: log success/failure, write latency, and any errors
- On load: log where state was loaded from, full tab list (abbreviated), and any migration or validation performed

Add logging to `storage.onChanged` listeners:
- In `background.js`: log when `quick_tabs_state_v2` changes, old vs. new tab counts, and whether the change is a self-write (ignored) or external
- In `sidebar/quick-tabs-manager.js`: log when Manager processes a storage change, what triggered a UI re-render, and any cache protection logic activated

Follow the pattern in `background.js` where X-Frame-Options bypass logs are comprehensive (lines 1395-1450).

---

## Issue 6: Minimize State Lost on Reload

### Problem
After minimizing a Quick Tab, reloading the browser extension (via `about:debugging` or browser restart) causes the Quick Tab to reappear in a non-minimized state, even though storage shows `minimized: true`. The window is visible on the page, defeating the purpose of minimize.

### Root Cause

**File:** `src/features/quick-tabs/handlers/VisibilityHandler.js`  
**Location:** `handleMinimize()` method (lines 87-111) and restore flow

**Issue:** When a Quick Tab is minimized, the handler sets `minimized: true` and removes the DOM, but does not persist a `domVerified: false` flag to indicate "this tab was minimized and should NOT have DOM rendered." 

On extension reload, `StateManager` loads the saved state including `minimized: true`, but the initialization flow in `QuickTabsManager` does not distinguish between "minimized by user" and "destroyed". The mediator sees `minimized: true` and initializes the Quick Tab in `MINIMIZED` state, but the restore path (which relies on `domVerified` checks) doesn't have enough information to know whether the tab had DOM before or after the last minimize.

As a result, the UICoordinator sometimes creates DOM for tabs marked `minimized: true` because the `domVerified` flag defaults to `undefined` (not explicitly `false`).

### Fix Required

Explicitly set `domVerified: false` when minimizing and persist it to storage. On restore or reload, check this flag to determine whether DOM should be created. Ensure the flag is cleared (set to `true` or removed) only after a successful restore with confirmed DOM rendering.

Follow the pattern where `domVerified` is already used in some restore flows (`sidebar/quick-tabs-manager.js` lines 1210-1223) but extend it to the minimize flow as well.

---

## Issue 7: Manager "Last Sync" Timestamp Incorrect

### Problem
The Manager sidebar's "Last sync" timestamp often shows times that don't match when the state was actually updated. For example, minimizing a tab at 1:30 PM might show "Last sync: 1:28 PM" in the Manager, creating confusion about whether the Manager is displaying current state.

### Root Cause

**File:** `sidebar/quick-tabs-manager.js`  
**Location:** `updateUIStats()` method (lines 534-553)

**Issue:** The "Last sync" timestamp is derived from `quickTabsState.timestamp`, which is set when storage was **written**, not when the Manager's UI was **updated**. If the Manager has cached state or processes a storage change with a delay (due to debouncing), the displayed timestamp can lag behind the actual UI update time.

Additionally, the timestamp is only updated when `latestTimestamp > 0` from storage, but if storage load fails or returns empty state, the "Last sync" shows "Never" even if the Manager has previously displayed tabs.

The method logs the timestamp update (lines 548-552) but does not log what triggered the update (storage change, message, poll, etc.), making it hard to diagnose timing issues.

### Fix Required

Change `updateUIStats` to set "Last sync" based on when the Manager's internal `quickTabsState` was last updated by **any source** (storage read, message, reconciliation), not just the storage write timestamp. Add a `lastLocalUpdateTime` property to track when the Manager's own state was refreshed.

Alternatively, rename the label to "Last storage write" to accurately reflect what the timestamp represents, and add a separate "Last UI update" timestamp.

Add logging to indicate what triggered each "Last sync" update (storage.onChanged, message, poll, reconciliation).

---

## Issue 8: Z-Index Desync Causes Focus Anomalies

### Problem
Clicking to focus a Quick Tab window sometimes fails to bring it to the front. Other times, a Quick Tab appears "stuck" behind another window even after being focused. The Manager's display order does not always match the visual stacking order on the page.

### Root Cause

**File:** `src/features/quick-tabs/managers/FocusManager.js`  
**Location:** `bringToFront()` method (lines 67-92)

**Issue:** When a Quick Tab is focused, `FocusManager.bringToFront` increments its `zIndex` and calls `quickTabWindow.updateZIndex(newZIndex)`, which updates the DOM `style.zIndex`. However, the new z-index is **not persisted to storage** unless another operation (like move or resize) happens to trigger a storage write.

If the page reloads or the extension restarts before another write occurs, the Quick Tab's z-index reverts to its old value from storage. The Manager's displayed tab order is based on storage state, not the live DOM z-index, so the order can appear incorrect.

Additionally, z-index updates bypass `StateManager.save()` entirely—there is no direct call to persist focus state.

### Fix Required

Add storage persistence after z-index updates in `FocusManager.bringToFront`. Include the updated z-index in the Quick Tab's storage state so the order is preserved across reloads.

Alternatively, trigger a batched state save that includes z-index changes along with other pending updates (position, size, etc.), using the existing debouncing pattern to avoid write storms.

Ensure the Manager's tab list rendering uses z-index from storage state (or live state messages) to display tabs in correct visual order.

---

## Shared Implementation Notes

- **Storage Write Pattern:** All state changes that affect Manager display or user-visible state must call `StateManager.save()` or equivalent to trigger `storage.onChanged` events. Follow the established pattern where writes include a unique `saveId` to prevent hash collisions and enable self-write detection.

- **Debouncing:** For high-frequency operations (drag, resize, focus), implement debouncing (100-200ms) to batch multiple rapid updates into a single storage write. This prevents write storms while ensuring state is not lost during crashes.

- **DOM Verification:** All operations that create or remove DOM (minimize, restore, destroy) must set and persist a `domVerified` flag so the extension can reliably reconstruct state on reload without duplicate windows or ghost elements.

- **Manager Sync:** Manager UI updates must be triggered by `storage.onChanged` or explicit message broadcasts. The Manager should not directly poll content scripts for state; instead, content scripts push state changes to storage, and Manager observes storage.

- **Logging Standards:** All storage writes, state transitions, and Manager UI updates must log:
  - Operation source (which user action or internal event triggered it)
  - Full state before/after (abbreviated for large objects)
  - Success/failure and any errors
  - Timing information (latency for storage operations)

<acceptanceCriteria>
### Issue 1
- Minimizing a Quick Tab immediately persists the minimized state to storage
- Manager indicator updates to yellow within 200ms
- Clearing a snapshot (on restore) triggers a storage write to update Manager

### Issue 2
- Restoring a Quick Tab never creates duplicate DOM containers
- Only one `render()` call occurs per restore operation
- Manual test: rapidly click restore 10 times → zero duplicate windows

### Issue 3
- Restore commands are sent only to the browser tab hosting the Quick Tab
- Manager uses `quickTabHostInfo` or `originTabId` to target messages
- Manual test in Zen split view: restore appears in correct pane 100% of time

### Issue 4
- Intermediate drag/resize updates are debounced and persisted within 200ms
- Manager shows live position/size updates during drag/resize
- Manual test: drag window, crash extension before releasing → position saved within 200ms

### Issue 5
- All `StateManager.save()` calls log operation source and full state snapshot
- All `storage.onChanged` listeners log old vs. new state and processing decision
- Log exports contain enough information to diagnose sync issues

### Issue 6
- Minimizing a Quick Tab sets and persists `domVerified: false`
- Extension reload after minimize does NOT render DOM for minimized tabs
- Manual test: minimize → reload → Quick Tab remains hidden

### Issue 7
- "Last sync" timestamp reflects when Manager UI was last updated
- Timestamp updates on every storage change, message, or reconciliation
- Log includes what triggered each timestamp update

### Issue 8
- Z-index updates are persisted to storage immediately
- Manager displays tabs in correct visual stacking order
- Manual test: focus tab → reload extension → tab remains on top

### All Issues
- All existing unit/integration tests pass
- No new console errors or warnings
- Storage writes are atomic and include unique `saveId`
- Manual test scenario: create tab → minimize → resize → restore → reload extension → verify all state preserved correctly
</acceptanceCriteria>

---

## Supporting Context

<details>
<summary>Issue 1: Log Evidence</summary>

From user log export (v1.6.3.5), minimize operation:

```
[MinimizedManager] Creating snapshot for: qt-abc123
[MinimizedManager] Snapshot created: { url: 'https://example.com', position: {...}, size: {...} }
[VisibilityHandler] Minimized: qt-abc123
[StateManager] Saved state: 3 tabs, saveId: 1733245891234-xyz
[Manager] storage.onChanged received: tabs: 3 → 3, saveId: ... → 1733245891234-xyz
[Manager] State unchanged (same hash), skipping cache update
```

Notice: After minimize, storage reports `3 → 3` tabs (no change) because MinimizedManager does not remove the tab from storage—it only creates a snapshot. Manager sees no change and does not update UI.

After restore:

```
[MinimizedManager] Clearing snapshot for: qt-abc123
[MinimizedManager] Snapshot cleared
[VisibilityHandler] Restored: qt-abc123
[Manager] Last sync: 1:28 PM
```

Notice: No `storage.onChanged` event after snapshot clear. Manager "Last sync" does not update because no storage write occurred.

</details>

<details>
<summary>Issue 2: Log Evidence</summary>

From debug logs during duplicate window bug:

```
[VisibilityHandler] handleRestore called for: qt-def456
[VisibilityHandler] Setting minimized=false on Quick Tab instance
[QuickTabWindow] render() called with dimensions: { left: 100, top: 100, width: 800, height: 600 }
[QuickTabWindow] Creating container element: quick-tab-qt-def456
[QuickTabWindow] Container created, appending to document.body
[VisibilityHandler] Notifying UICoordinator of restore
[UICoordinator] update() called for: qt-def456
[UICoordinator] Tab is not minimized and not rendered, calling render()
[QuickTabWindow] render() called with dimensions: { left: 100, top: 100, width: 800, height: 600 }
[QuickTabWindow] Creating container element: quick-tab-qt-def456
[QuickTabWindow] Container created, appending to document.body
```

Two separate `render()` calls, two separate "Creating container element" logs with same ID. The second call creates a second DOM element with the same `id` attribute, violating HTML uniqueness constraint and causing the duplicate window.

</details>

<details>
<summary>Issue 3: Log Evidence</summary>

From Zen Browser split-view scenario:

```
[Manager] Sending RESTORE_QUICK_TAB to 4 tabs for: qt-ghi789
[Content Script Tab 12] Received RESTORE_QUICK_TAB for: qt-ghi789
[Content Script Tab 12] No Quick Tab with ID qt-ghi789 found, ignoring
[Content Script Tab 15] Received RESTORE_QUICK_TAB for: qt-ghi789
[Content Script Tab 15] Quick Tab qt-ghi789 found, restoring...
[Content Script Tab 15] Restore complete
[Content Script Tab 18] Received RESTORE_QUICK_TAB for: qt-ghi789
[Content Script Tab 18] No Quick Tab with ID qt-ghi789 found, ignoring
[Content Script Tab 21] Received RESTORE_QUICK_TAB for: qt-ghi789
[Content Script Tab 21] No Quick Tab with ID qt-ghi789 found, ignoring
```

Quick Tab appears in Tab 15, but user was viewing Tab 12 (different pane in split view). Expected behavior: message should only be sent to the tab that created the Quick Tab (tracked in `quickTabHostInfo` as `originTabId: 12`).

</details>

<details>
<summary>Issue 4: Log Evidence</summary>

From drag operation interrupted by crash:

```
[DragController] Drag started: qt-jkl012
[UpdateHandler] handlePositionChange: qt-jkl012, x: 110, y: 105
[UpdateHandler] handlePositionChange: qt-jkl012, x: 125, y: 110
[UpdateHandler] handlePositionChange: qt-jkl012, x: 145, y: 120
[UpdateHandler] handlePositionChange: qt-jkl012, x: 160, y: 125
<extension crash / reload>
[StateManager] Loading state from storage...
[StateManager] Loaded state: 1 tabs
[QuickTabsManager] Restoring Quick Tab: qt-jkl012 at (100, 100)
```

After reload, Quick Tab position reverts to `(100, 100)` (original storage value) instead of the last dragged position `(160, 125)`. Intermediate positions were never saved.

</details>

<details>
<summary>Issue 5: Storage Architecture Context</summary>

The Manager relies on `storage.onChanged` listener (`sidebar/quick-tabs-manager.js` line 1327) which only fires when `browser.storage.local.set()` or `.remove()` is explicitly called by some extension context. Per MDN documentation:

> "Fired when one or more items change in a storage area."

The event does **not** fire for:
- In-memory state changes without a storage write
- Changes in one context that only update local variables
- DOM-only updates that don't touch storage

For the Manager to reflect current state, every state-changing operation must call `StateManager.save()` or equivalent to trigger a storage write and thus a `storage.onChanged` event. This is the contract that makes the Manager's reactive UI model work.

Missing logging makes it difficult to verify that this contract is being upheld. When a user reports "Manager not updating," logs should clearly show:
1. What operation occurred (minimize, restore, etc.)
2. Whether that operation called `save()`
3. What was written to storage
4. Whether `storage.onChanged` fired in Manager
5. What the Manager did in response

Currently, logs only show partial information, making diagnosis difficult.

</details>

<details>
<summary>Issue 6: domVerified Flag Usage</summary>

From `sidebar/quick-tabs-manager.js` restore flow:

```javascript
// After restore, verify DOM was rendered
setTimeout(async () => {
  const state = await browser.storage.local.get(STATE_KEY);
  const tab = state?.tabs?.find(t => t.id === quickTabId);
  
  if (tab && tab.domVerified === false) {
    console.warn('[Manager] Restore WARNING: DOM not verified after restore:', quickTabId);
    // UI shows orange indicator
  }
}, DOM_VERIFICATION_DELAY_MS);
```

The code already checks `domVerified` to detect failed restores (orange indicator), but the flag is not set during minimize operations. This means:
- After minimize, `domVerified` remains `true` (or `undefined`)
- On extension reload, initialization logic sees a tab with `minimized: true` but no explicit `domVerified: false`
- Without a clear signal, the system may attempt to render DOM for minimized tabs

Setting `domVerified: false` during minimize and persisting it provides a clear signal: "this tab should NOT have DOM rendered until explicitly restored."

</details>

---

**Priority:** Critical (Issues 1, 2), High (Issues 3, 4, 5), Medium (Issues 6, 7, 8)  
**Target:** Single coordinated PR fixing all issues  
**Estimated Complexity:** High (due to cross-component coordination requirements)

---

