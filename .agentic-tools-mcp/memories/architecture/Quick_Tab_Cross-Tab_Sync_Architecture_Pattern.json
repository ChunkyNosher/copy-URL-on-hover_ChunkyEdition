{
  "id": "c2baed27-3d42-4b53-9da8-41af42b15a69",
  "title": "Quick Tab Cross-Tab Sync Architecture Pattern",
  "details": "## Quick Tab Cross-Tab Synchronization Architecture\n\nThe extension uses a three-layer synchronization system for cross-tab Quick Tab state:\n\n### Layer 1: Real-time BroadcastChannel\n- **Purpose**: Fast <10ms cross-tab notifications of changes\n- **Channel**: `quick-tabs-sync-{cookieStoreId}`\n- **Messages**: CREATE, UPDATE_POSITION, UPDATE_SIZE, SOLO, MUTE, MINIMIZE, RESTORE, CLOSE\n- **Handled by**: SyncCoordinator._routeMessage()\n\n### Layer 2: Persistent browser.storage.local\n- **Purpose**: Reliable state persistence across sessions\n- **Key**: `quick_tabs_state_v2` (container-aware)\n- **Triggered by**: Background script on every Quick Tab change\n- **Handled by**: SyncCoordinator.handleStorageChange()\n\n### Layer 3: Tab Visibility Refresh\n- **Purpose**: Ensure UI matches state when tab becomes visible\n- **Trigger**: `visibilitychange` event (document becomes visible)\n- **Flow**: EventManager → SyncCoordinator.handleTabVisible() → StateManager.hydrate() → UICoordinator._refreshAllRenderedTabs()\n\n## Critical Pattern: Tab Visibility Refresh\n\nWhen a tab becomes visible after being hidden:\n\n1. **SyncCoordinator.handleTabVisible()** called\n2. Re-loads complete state from storage: `await storageManager.loadAll()`\n3. Hydrates StateManager: `stateManager.hydrate(quickTabs)`\n4. Emits `state:refreshed` event\n5. **UICoordinator** listens for `state:refreshed`\n6. Calls `_refreshAllRenderedTabs()` which:\n   - Destroys Quick Tabs that should no longer be visible\n   - Updates existing rendered tabs with latest positions/sizes/z-indexes\n   - Renders newly visible tabs\n\n## Common Bugs and Solutions\n\n### Bug: UI Not Updating When Tab Becomes Visible\n**Symptom**: Quick Tab positions/sizes don't update when switching tabs\n**Cause**: UICoordinator not listening to `state:refreshed` event\n**Solution**: Add listener for `state:refreshed` in `setupStateListeners()` and implement `_refreshAllRenderedTabs()`\n\n### Bug: Closed Quick Tabs Reappear\n**Symptom**: Quick Tabs closed in Tab 1 still visible in Tab 2\n**Cause**: StateManager.hydrate() only tracks additions, not deletions\n**Solution**: Compare existing IDs with incoming IDs, emit `state:deleted` for removed Quick Tabs\n\n### Bug: Panel Initialization Race Condition\n**Symptom**: \"can't access property 'setIsOpen', this.contentManager is null\"\n**Cause**: _applyState() called before contentManager initialized\n**Solution**: Initialize controllers BEFORE loading/applying state in PanelManager.init()\n\n## State Event Flow\n\n```\nUser Action (move Quick Tab)\n  ↓\nHandler (UpdateHandler.handlePositionChangeEnd)\n  ↓\nStateManager.update() → emit('state:updated', quickTab)\n  ↓\nUICoordinator.update() → update DOM\n  ↓\nSave to background (browser.runtime.sendMessage)\n  ↓\nBackground saves to storage → emit storage change\n  ↓\nOther tabs receive storage change\n  ↓\nSyncCoordinator.handleStorageChange()\n  ↓\nStateManager.hydrate() → emit('state:updated', quickTab)\n  ↓\nUICoordinator.update() → update DOM in other tabs\n```\n\n## Key Principles\n\n1. **Always emit proper events from StateManager.hydrate()**: added, updated, deleted\n2. **UICoordinator must listen to state:refreshed**: Not just added/updated/deleted\n3. **Panel components must be initialized in order**: Panel → Controllers → State\n4. **Visibility logic is in domain entity**: QuickTab.shouldBeVisible(tabId)\n5. **BroadcastChannel is fast, storage is reliable**: Use both layers",
  "category": "architecture",
  "dateCreated": "2025-11-22T04:36:49.043Z",
  "dateUpdated": "2025-11-22T04:36:49.043Z"
}