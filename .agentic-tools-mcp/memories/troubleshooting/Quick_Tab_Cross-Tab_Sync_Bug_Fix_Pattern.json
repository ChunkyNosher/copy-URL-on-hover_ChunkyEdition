{
  "id": "ac57194e-598e-4e8e-95b9-cbed85311226",
  "title": "Quick Tab Cross-Tab Sync Bug Fix Pattern",
  "details": "## Quick Tab Cross-Tab Sync Common Bugs and Solutions\n\n### Bug 1: Quick Tabs Don't Update When Switching Tabs\n**Symptoms:**\n- Quick Tab positions/sizes are stale when switching to a different tab\n- Quick Tab deletions in Tab 1 don't reflect in Tab 2\n- Quick Tabs appear that shouldn't be visible on current tab\n\n**Root Cause:**\nUICoordinator only listens to `state:added`, `state:updated`, `state:deleted` events, but not `state:refreshed`. When tab becomes visible, SyncCoordinator emits `state:refreshed` after reloading from storage, but UICoordinator doesn't react.\n\n**Solution:**\n1. Add `state:refreshed` listener in UICoordinator.setupStateListeners()\n2. Implement `_refreshAllRenderedTabs()` method:\n   - Get all visible Quick Tabs from StateManager\n   - Destroy rendered tabs that are no longer visible\n   - Update rendered tabs with latest state\n   - Render newly visible tabs\n\n**Code:**\n```javascript\n// UICoordinator.setupStateListeners()\nthis.eventBus.on('state:refreshed', () => {\n  console.log('[UICoordinator] State refreshed - re-rendering all visible tabs');\n  this._refreshAllRenderedTabs();\n});\n\n_refreshAllRenderedTabs() {\n  const visibleTabs = this.stateManager.getVisible();\n  const visibleIds = new Set(visibleTabs.map(qt => qt.id));\n\n  // Destroy no-longer-visible tabs\n  for (const [id, _] of this.renderedTabs) {\n    if (!visibleIds.has(id)) {\n      this.destroy(id);\n    }\n  }\n\n  // Update or render visible tabs\n  for (const quickTab of visibleTabs) {\n    if (this.renderedTabs.has(quickTab.id)) {\n      this.update(quickTab);\n    } else {\n      this.render(quickTab);\n    }\n  }\n}\n```\n\n### Bug 2: Deleted Quick Tabs Reappear in Other Tabs\n**Symptoms:**\n- Close Quick Tab in Tab 1\n- Switch to Tab 2\n- Quick Tab is still visible in Tab 2\n\n**Root Cause:**\nStateManager.hydrate() only tracks additions, not deletions. When storage changes with a removed Quick Tab:\n1. hydrate() clears the Map and rebuilds it\n2. Only emits `state:hydrated` event (not `state:deleted`)\n3. UICoordinator never receives deletion event\n4. DOM element remains in page\n\n**Solution:**\nTrack existing IDs before hydration, compare with incoming IDs after, emit proper events:\n\n**Code:**\n```javascript\n// StateManager.hydrate()\nhydrate(quickTabs) {\n  // Track existing IDs to detect deletions\n  const existingIds = new Set(this.quickTabs.keys());\n  const incomingIds = new Set();\n\n  // Process incoming (add/update)\n  for (const qt of quickTabs) {\n    incomingIds.add(qt.id);\n    if (existingIds.has(qt.id)) {\n      this.quickTabs.set(qt.id, qt);\n      this.eventBus?.emit('state:updated', { quickTab: qt });\n    } else {\n      this.quickTabs.set(qt.id, qt);\n      this.eventBus?.emit('state:added', { quickTab: qt });\n    }\n  }\n\n  // Detect deletions\n  for (const existingId of existingIds) {\n    if (!incomingIds.has(existingId)) {\n      const deletedQt = this.quickTabs.get(existingId);\n      this.quickTabs.delete(existingId);\n      this.eventBus?.emit('state:deleted', { id: existingId, quickTab: deletedQt });\n    }\n  }\n}\n```\n\n### Bug 3: Panel Manager Crashes on New Tab Load\n**Symptoms:**\n- Panel open in Tab 1\n- Switch to newly loaded Tab 2\n- Error: \"can't access property 'setIsOpen', this.contentManager is null\"\n- Panel stuck, can't be moved or closed\n\n**Root Cause:**\nInitialization order issue:\n1. PanelManager.init() creates stateManager\n2. stateManager.init() loads state from storage\n3. If state.isOpen=true, onStateLoaded callback fires\n4. Callback calls _applyState() which calls open()\n5. open() tries to call this.contentManager.setIsOpen()\n6. But contentManager hasn't been initialized yet!\n\n**Solution:**\nFix initialization order:\n1. Create stateManager instance FIRST\n2. Call stateManager.init() - loads state, applies position/size\n3. Initialize controllers (including contentManager)\n4. Apply state AGAIN to handle isOpen with contentManager ready\n\n**Code:**\n```javascript\n// PanelManager.init()\nasync init() {\n  // ... create panel ...\n\n  // Initialize state manager FIRST\n  this.stateManager = new PanelStateManager({\n    onStateLoaded: state => this._applyState(state),\n    onBroadcastReceived: (type, data) => this._handleBroadcast(type, data)\n  });\n  await this.stateManager.init();\n\n  // Now initialize controllers\n  this._initializeControllers();\n\n  // Apply state AGAIN after controllers ready\n  const savedState = this.stateManager.getState();\n  this._applyState(savedState);\n}\n\n// _applyState with null safety\n_applyState(state) {\n  // ... apply position/size ...\n\n  // Only call open() if contentManager exists\n  if (state.isOpen && this.contentManager) {\n    this.open();\n  }\n}\n```\n\n### Critical Event Flow for Tab Visibility\n\n```\nUser switches to Tab 2\n  ↓\ndocument visibilitychange event fires\n  ↓\nEventManager emits 'event:tab-visible'\n  ↓\nSyncCoordinator.handleTabVisible()\n  ↓\nstorageManager.loadAll() - get latest state from storage\n  ↓\nstateManager.hydrate(quickTabs) - update in-memory state\n  ↓\nemit state:added, state:updated, state:deleted for each change\n  ↓\nemit state:refreshed event\n  ↓\nUICoordinator._refreshAllRenderedTabs()\n  ↓\nUI now matches latest state with correct positions/sizes/visibility\n```\n\n### Testing Checklist\n\nWhen fixing cross-tab sync bugs, verify:\n- [ ] Create Quick Tab in Tab 1, switch to Tab 2 - appears\n- [ ] Move Quick Tab in Tab 1, switch to Tab 2 - position updated\n- [ ] Close Quick Tab in Tab 1, switch to Tab 2 - disappears\n- [ ] Open Panel in Tab 1, switch to Tab 2 - no crash\n- [ ] Solo Quick Tab in Tab 1, switch to Tab 2 - not visible (if different tab)\n- [ ] Mute Quick Tab in Tab 2, switch to Tab 1 - still visible\n\n### Prevention Pattern\n\nAlways ensure event chains are complete:\n1. **State change** → emit proper event (added/updated/deleted)\n2. **Storage change** → hydrate with proper event emission\n3. **Tab visibility** → refresh with state:refreshed event\n4. **UI coordinator** → listen to ALL relevant events including refresh\n\nNever assume UI will stay in sync automatically - always have explicit refresh paths.",
  "category": "troubleshooting",
  "dateCreated": "2025-11-22T04:40:40.434Z",
  "dateUpdated": "2025-11-22T04:40:40.434Z"
}